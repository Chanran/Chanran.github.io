{"meta":{"title":"blue's blog","subtitle":"coding is funny.","description":"记录着blue的技术生涯--前端,后端,服务器遇到的各种问题以及感悟的博客","author":"blue","url":"https://chanran.github.io"},"pages":[{"title":"","date":"2016-11-01T05:22:25.021Z","updated":"2016-11-01T05:22:25.021Z","comments":false,"path":"tags/index.html","permalink":"https://chanran.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2016-10-31T12:06:20.044Z","updated":"2016-10-31T12:06:20.044Z","comments":false,"path":"categories/index.html","permalink":"https://chanran.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"转载-常用端口速查","slug":"转载-常用端口速查","date":"2016-12-16T09:57:31.000Z","updated":"2016-12-16T09:59:50.065Z","comments":true,"path":"2016/12/16/转载-常用端口速查/","link":"","permalink":"https://chanran.github.io/2016/12/16/转载-常用端口速查/","excerpt":"","text":"转载自：《常用端口速查》 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752常见端口0|无效端口,通常用于分析操作系统1|传输控制协议端口服务多路开关选择器2|管理实用程序3|压缩进程5|远程作业登录7|回显9|丢弃11|在线用户13|时间17|每日引用18|消息发送协议19|字符发生器20|FTP文件传输协议(默认数据口)21|FTP文件传输协议(控制)22|SSH远程登录协议23|telnet(终端仿真协议),木马Tiny Telnet Server开放此端口24|预留给个人用邮件系统25|SMTP服务器所开放的端口，用于发送邮件27|NSW 用户系统 FE29|MSG ICP31|MSG验证,木马Master Paradise、HackersParadise开放此端口33|显示支持协议35|预留给个人打印机服务37|时间38|路由访问协议39|资源定位协议41|图形42|主机名服务43|who is服务44|MPM(消息处理模块)标志协议45|消息处理模块46|消息处理模块(默认发送口)47|NI FTP48|数码音频后台服务49|TACACS登录主机协议50|远程邮件检查协议51|IMP(接口信息处理机)逻辑地址维护52|施乐网络服务系统时间协议53|dns域名服务器54|施乐网络服务系统票据交换55|ISI图形语言56|施乐网络服务系统验证57|预留个人用终端访问58|施乐网络服务系统邮件59|预留个人文件服务60|未定义61|NI邮件62|异步通讯适配器服务63|whois++64|通讯接口65|TACACS数据库服务66|Oracle SQL*NET67|引导程序协议服务端68|引导程序协议客户端69|小型文件传输协议70|信息检索协议71|远程作业服务72|远程作业服务73|远程作业服务74|远程作业服务75|预留给个人拨出服务76|分布式外部对象存储77|预留给个人远程作业输入服务78|修正TCP79|查询远程主机在线用户等信息80|http,用于网页浏览,木马Executor开放此端口81|HOST2名称服务82|传输实用程序83|模块化智能终端ML设备84|公用追踪设备85|模块化智能终端ML设备86|Micro Focus Cobol编程语言87|预留给个人终端连接88|Kerberros安全认证系统89|SU/MIT telnet(终端仿真网关)90|DNSIX 安全属性标记图91|MIT Dover假脱机92|网络打印协议93|设备控制协议94|Tivoli对象调度96|DIXIE协议规范97|快速远程虚拟文件协议98|TAC新闻协议99|后门程序ncx99开放此端口100|未知用途101|NIC 主机名称服务102|消息传输代理103|Genesis 点对点传输网络105|信箱名称服务106|3COM-TSMUX开放端口107|远程Telnet服务108|SNA 网关访问服务109|POP2服务器开放此端口,用于接收邮件110|POP3服务器开放此端口,用于接收邮件111|SUN公司的RPC服务所有端口112|McIDAS 数据传输协议113|认证服务，用于鉴别TCP连接的用户114|音频新闻多点服务115|简单文件传输服务116|ANSA REX 通知117|UUCP 路径服务118|SQL 服务119|NEWS新闻组传输协议，承载USENET通信121|木马BO jammerkillahV开放端口122|SMAKY网络123|网络时间协议，蠕虫病毒会利用，一般关闭128|GSS X许可认证129|密码生成器协议130|Cisco软件开放端口131|Cisco软件开放端口132|Cisco软件开放端口133|统计服务134|INGRES-网络服务135|DCOM服务，冲击波病毒利用，不能关闭136|命名系统137|NETBIOS协议应用，为共享开放138|NETBIOS协议应用，为共享开放139|NETBIOS协议应用，为共享开放140|EMFIS数据服务141|EMFIS控制服务143|Interim邮件访问协议144|UMA软件开放端口145|UAAC协议149|AED 512仿真服务150|SQL(结构化查询语言)-网络152|后台文件传输协议156|SQL(结构化查询语言)服务158|PC邮件服务器159|NSS-路由160|SGMP-陷阱161|简单网络管理协议162|SNMP陷阱163|CMIP/TCP 管理164|CMIP/TCP 代理166|Sirius系统169|发送170|网络附言177|x显示管理控制协议，入侵者通过它访问X-windows操作台178|NextStep Window 服务179|边界网关协议180|图表181|统一184|OC服务器185|远程-KIS186|KIS 协议187|应用通信接口189|队列文件传输190|网关进入控制协议191|Prospero 目录服务192|OSU 网络监视系统193|Spider 远程控制协议194|多线交谈协议197|目录地址服务198|目录地址服务监视器200|IBM系统资源控制器201|AppleTalk(Mac机所用的网络协议)路由保证202|AppleTalk(Mac机所用的网络协议)Name Binding203|AppleTalk(Mac机所用的网络协议)未用端口204|AppleTalk(Mac机所用的网络协议)回显205|AppleTalk(Mac机所用的网络协议)未用端口206|AppleTalk(Mac机所用的网络协议)区信息207|AppleTalk(Mac机所用的网络协议)未用端口208|AppleTalk(Mac机所用的网络协议)未用端口209|快速邮件传输协议210|ANSI(美国国家标准协会)Z39.50211|Texas Instruments 914C/G终端213|IPX(以太网所用的协议)218|Netix消息记录协议219|Unisys ARPs220|交互邮件访问协议 v3223|证书分发中心224|masq拨号器241|预留端口 (224-241)245|链接246|显示系统协议257|安全电子交易系统258|Yak Winsock 个人聊天259|有效短程遥控260|开放端口261|IIOP 基于TLS/SSL的命名服务266|SCSI(小型计算机系统接口)on ST267|Tobit David服务层268|Tobit David复制281|个人连结282|Cable端口A/X286|FXP通信308|Novastor备份313|Magenta逻辑318|PKIX时间标记333|Texar安全端口344|Prospero数据存取协议345|Perf分析工作台346|Zebra服务器347|Fatmen服务器348|Cabletron管理协议358|Shrink可上网家电协议359|网络安全风险管理协议362|SRS发送363|RSVP隧道372|列表处理373|Legend公司374|Legend公司376|AmigaEnvoy网络查询协议377|NEC公司378|NEC公司379|TIA/EIA/IS-99调制解调器客户端380|TIA/EIA/IS-99调制解调器服务器381|hp(惠普)性能数据收集器382|hp(惠普)性能数据控制节点383|hp(惠普)性能数据警报管理384|远程网络服务器系统385|IBM应用程序386|ASA信息路由器定义文件.387|Appletalk更新路由.389|轻型目录访问协议395|网络监视控制协议396|Novell(美国Novell公司)Netware(Novell公司出的网络操作系统)over IP400|工作站解决方案401|持续电源402|Genie协议406|交互式邮件支持协议408|Prospero资源管理程序409|Prospero资源节点管理.410|DEC(数据设备公司)远程调试协议411|远程MT协议412|陷阱协定端口413|存储管理服务协议414|信息查询415|B网络423|IBM操作计划和控制开端424|IBM操作计划和控制追踪425|智能计算机辅助设计427|服务起位置434|移动ip代理435|移动ip管理443|基于TLS/SSL的网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP444|简单网络内存分页协议445|Microsoft-DS，为共享开放，震荡波病毒利用，一般应关闭446|DDM-远程关系数据库访问447|DDM-分布式文件管理448|DDM-使用安全访问远程数据库456|木马HACKERS PARADISE开放此端口458|apple quick time软件开放端口459|ampr-rcmd命令464|k密码服务469|广播控制协议470|scx-代理472|ljk-登陆481|Ph服务487|简单异步文件传输489|nest-协议491|Go-登陆499|ISO ILL协议500|Internet密钥交换，Lsass开放端口，不能关闭509|陷阱510|FirstClass协议512|远程进程执行513|远程登陆514|cmd命令515|spooler516|可视化数据518|交谈519|unix时间520|扩展文件名称服务器525|时间服务526|新日期529|在线聊天系统服务530|远程过程调用531|聊天532|读新闻533|紧急广播端口534|MegaMedia管理端537|网络流媒体协议542|商业543|Kerberos(软件)v4/v5544|krcmd命令546|DHCPv6 客户端547|DHCPv6 服务器552|设备共享554|Real Time Stream控制协议555|木马PhAse1.0、Stealth Spy、IniKiller开放此端口556|远距离文件服务器563|基于TLS/SSL的网络新闻传输协议564|plan 9文件服务565|whoami查询566|streettalk567|banyan-rpc(远程过程调用)568|DPA成员资格569|MSN成员资格570|demon(调试监督程序)571|udemon(调试监督程序)572|声纳573|banyan-贵宾574|FTP软件代理系统581|Bundle Discovery 协议582|SCC安全583|Philips视频会议584|密钥服务器585|IMAP4+SSL (Use 993 instead)586|密码更改587|申请589|Eye连结595|CAB协议597|PTC名称服务598|SCO网络服务器管理3599|Aeolon Core协议600|Sun IPC(进程间通讯)服务器601|可靠系统登陆服务604|通道606|Cray统一资源管理608|发送人-传递/提供 文件传输器609|npmp-陷阱610|npmp-本地611|npmp-gui( 图形用户界面)612|HMMP指引613|HMMP操作614|SSL(加密套接字协议层)shell(壳)615|Internet配置管理616|SCO(Unix系统)系统管理服务器617|SCO桌面管理服务器619|Compaq(康柏公司)EVM620|SCO服务器管理623|ASF远程管理控制协议624|Crypto管理631|IPP (Internet打印协议)633|服务更新(Sterling软件)637|局域网服务器641|repcmd命令647|DHCP(动态主机配置协议)Failover648|注册登记协议(RRP)649|Cadview-3d软件协议666|木马Attack FTP、Satanz Backdoor开放此端口808|ccproxy http/gopher/ftp (over http)协议1001|木马Silencer，WebEx开放端口1011|木马Doly开放端口1024|动态端口的开始,木马yai开放端口1025|inetinfo.exe(互联网信息服务)木马netspy开放端口1026|inetinfo.exe(互联网信息服务)1027|应用层网关服务1030|应用层网关服务1031|BBN IAD1033|本地网络信息端口1034|同步通知1036|安全部分传输协议1070|木马Psyber Stream，Streaming Audio开放端口1071|网络服务开放端口1074|网络服务开放端口1080|Socks这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET1110|卡巴斯基反病毒软件开放此端口1125|卡巴斯基反病毒软件开放此端口1203|许可证生效端口1204|登陆请求监听端口1206|Anthony数据端口1222|SNI R&amp;D网络端口1233|普遍的附录服务器端口1234|木马SubSeven2.0、Ultors Trojan开放此端口1243|木马SubSeven1.0/1.9开放此端口1245|木马Vodoo，GabanBus，NetBus，Vodoo开放此端口1273|EMC-网关端口1289|JWalk服务器端口1290|WinJa服务器端口1333|密码策略(网络服务)(svchost.exe)1334|网络服务(svchost.exe)1335|数字公正协议1336|即时聊天协议(svchost.exe)1349|注册网络协议端口1350|注册网络协议端口1371|富士通配置协议端口1372|富士通配置协议端口1374|EPI软件系统端口1376|IBM个人-个人软件端口1377|Cichlid许可证管理端口1378|Elan许可证管理端口1380|Telesis网络许可证管理端口1381|苹果网络许可证管理端口1386|CheckSum 许可证管理端口1387|系统开放端口(rundll32.exe)1388|数据库高速缓存端口1389|文档管理端口1390|存储控制器端口1391|存储器存取服务器端口1392|打印管理端口1393|网络登陆服务器端口1394|网络登陆客户端端口1395|PC工作站管理软件端口1396|DVL活跃邮件端口1397|音频活跃邮件端口1398|视频活跃邮件端口1399|Cadkey许可证管理端口1433|Microsoft的SQL服务开放端口1434|Microsoft的SQL服务监视端口1492|木马FTP99CMP开放此端口1509|木马Psyber Streaming Server开放此端口1512|Microsoft Windows网络名称服务1524|许多攻击脚本安装一个后门SHELL于这个端口1600|木马Shivka-Burka开放此端口1645|远程认证拨号用户服务1701|第2层隧道协议1731|NetMeeting音频调用控制1801|Microsoft消息队列服务器1807|木马SpySender开放此端口1900|可被利用ddos攻击，一般关闭1912|金山词霸开放此端口1981|木马ShockRave开放此端口1999|木马BackDoor,yai开放此端口2000|木马GirlFriend 1.3、Millenium 1.0开放此端口2001|木马Millenium 1.0、Trojan Cow,黑洞2001开放此端口2003|GNU 查询2023|木马Pass Ripper开放此端口2049|NFS程序常运行于此端口2115|木马Bugs开放此端口2140|木马Deep Throat 1.0/3.0，The Invasor开放此端口2500|应用固定端口会话复制的RPC客户2504|网络平衡负荷2565|木马Striker开放此端口2583|木马Wincrash 2.0开放此端口2801|木马Phineas Phucker开放此端口2847|诺顿反病毒服务开放此端口3024|木马WinCrash开放此端口3128|squid http代理服务器开放此端口3129|木马Master Paradise开放此端口3150|木马The Invasor,deep throat开放此端口3210|木马SchoolBus开放此端口3306|MySQL开放此端口3333|木马Prosiak开放此端口3389|WINDOWS 2000终端开放此端口3456|inetinfo.exe(互联网信息服务)开放端口，VAT默认数据3457|VAT默认控制3527|Microsoft消息队列服务器3700|木马Portal of Doom开放此端口3996|木马RemoteAnything开放此端口4000|腾讯QQ客户端开放此端口4060|木马RemoteAnything开放此端口4092|木马WinCrash开放此端口4133|NUTS Bootp服务器4134|NIFTY-Serve HMI协议4141|Workflow服务器4142|文档服务器4143|文档复制4145|VVR控制4321|远程Who Is查询4333|微型sql服务器4349|文件系统端口记录4350|网络设备4351|PLCY网络服务4453|NSS警报管理4454|NSS代理管理4455|PR聊天用户4456|PR聊天服务器4457|PR注册4480|Proxy+ HTTP代理端口4500|Lsass开放端口，不能关闭4547|Lanner许可管理4555|RSIP端口4590|木马ICQTrojan开放此端口4672|远程文件访问服务器4752|简单网络音频服务器4800|Icona快速消息系统4801|Icona网络聊天4802|Icona许可系统服务器4848|App服务器-Admin HTTP4849|App服务器-Admin HTTPS4950|木马IcqTrojan开放5000端口5000|木马blazer5，Sockets de Troie开放5000端口，一般应关闭5001|木马Sockets de Troie开放5001端口5006|wsm服务器5007|wsm服务器ssl5022|mice服务器5050|多媒体会议控制协议5051|ITA代理5052|ITA管理5137|MyCTS服务器端口5150|Ascend通道管理协议5154|BZFlag游戏服务器5190|America-Online(美国在线)5191|AmericaOnline1(美国在线)5192|AmericaOnline2(美国在线)5193|AmericaOnline3(美国在线)5222|Jabber客户端连接5225|HP(惠普公司)服务器5226|HP(惠普公司)5232|SGI绘图软件端口5250|i网关5264|3Com网络端口15265|3Com网络端口25269|Jabber服务器连接5306|Sun MC组5321|木马Sockets de Troie开放5321端口5400|木马Blade Runner开放此端口5401|木马Blade Runner开放此端口5402|木马Blade Runner开放此端口5405|网络支持5409|Salient数据服务器5410|Salient用户管理5415|NS服务器5416|SNS网关5417|SNS代理5421|网络支持25423|虚拟用户5427|SCO-PEER-TTA(Unix系统)5432|PostgreSQL数据库5550|木马xtcp开放此端口5569|木马Robo-Hack开放此端口5599|公司远程安全安装5600|公司安全管理5601|公司安全代理5631|pcANYWhere(软件)数据5632|pcANYWhere(软件)数据5673|JACL消息服务器5675|V5UA应用端口5676|RA管理5678|远程复制代理连接5679|直接电缆连接5720|MS-执照5729|Openmail用户代理层5730|Steltor&apos;s日历访问5731|netscape(网景)suiteware5732|netscape(网景)suiteware5742|木马WinCrash1.03开放此端口5745|fcopy-服务器5746|fcopys-服务器5755|OpenMail(邮件服务器)桌面网关服务器5757|OpenMail(邮件服务器)X.500目录服务器5766|OpenMail (邮件服务器)NewMail服务器5767|OpenMail (邮件服务器)请求代理曾(安全)5768|OpenMail(邮件服务器) CMTS服务器5777|DALI端口5800|虚拟网络计算5801|虚拟网络计算5802|虚拟网络计算HTTP访问, d5803|虚拟网络计算HTTP访问, d5900|虚拟网络计算机显示05901|虚拟网络计算机显示15902|虚拟网络计算机显示25903|虚拟网络计算机显示36000|X Window 系统6001|X Window 服务器6002|X Window 服务器6003|X Window 服务器6004|X Window 服务器6005|X Window 服务器6006|X Window 服务器6007|X Window 服务器6008|X Window 服务器6009|X Window 服务器6456|SKIP证书发送6471|LVision许可管理器6505|BoKS管理私人端口6506|BoKS管理公共端口6507|BoKS Dir服务器,私人端口6508|BoKS Dir服务器,公共端口6509|MGCS-MFP端口6510|MCER端口6566|SANE控制端口6580|Parsec主服务器6581|Parsec对等网络6582|Parsec游戏服务器6588|AnalogX HTTP代理端口6631|Mitchell电信主机6667|Internet多线交谈6668|Internet多线交谈6670|木马Deep Throat开放此端口6671|木马Deep Throat 3.0开放此端口6699|Napster文件(MP3)共享服务6701|KTI/ICAD名称服务器6788|SMC软件-HTTP6789|SMC软件-HTTPS6841|Netmo软件默认开放端口6842|Netmo HTTP服务6883|木马DeltaSource开放此端口6939|木马Indoctrination开放此端口6969|木马Gatecrasher、Priority开放此端口6970|real音频开放此端口7000|木马Remote Grab开放此端口7002|使用者&amp; 组 数据库7003|音量定位数据库7004|AFS/Kerberos认证服务7005|音量管理服务7006|错误解释服务7007|Basic监督进程7008|服务器-服务器更新程序7009|远程缓存管理服务7011|Talon软件发现端口7012|Talon软件引擎7013|Microtalon发现7014|Microtalon通信7015|Talon网络服务器7020|DP服务7021|DP服务管理7100|X字型服务7121|虚拟原型许可证管理7300|木马NetMonitor开放此端口7301|木马NetMonitor开放此端口7306|木马NetMonitor，NetSpy1.0开放此端口7307|木马NetMonitor开放此端口7308|木马NetMonitor开放此端口7323|Sygate服务器端7511|木马聪明基因开放此端口7588|Sun许可证管理7597|木马Quaz开放此端口7626|木马冰河开放此端口7633|PMDF管理7674|iMQ SSL通道7675|iMQ通道7676|木马Giscier开放此端口7720|Med图象入口7743|Sakura脚本传递协议7789|木马ICKiller开放此端口7797|Propel连接器端口7798|Propel编码器端口8000|腾讯QQ服务器端开放此端口8001|VCOM通道8007|Apache(类似iis)jServ协议1.x8008|HTTP Alternate8009|Apache(类似iis)JServ协议1.38010|Wingate代理开放此端口8011|木马way2.4开放此端口8022|OA-系统8080|WWW代理开放此端口8081|ICECap控制台8082|BlackIce(防止黑客软件)警报发送到此端口8118|Privoxy HTTP代理8121|Apollo数据端口8122|Apollo软件管理端口8181|Imail8225|木马灰鸽子开放此端口8311|木马初恋情人开放此端口8351|服务器寻找8416|eSpeech Session协议8417|eSpeech RTP协议8473|虚拟点对点8668|网络地址转换8786|Message客户端8787|Message服务器8954|Cumulus管理端口9000|CS监听9001|ETL服务管理9002|动态id验证9021|Pangolin验证9022|PrivateArk远程代理9023|安全网络登陆-19024|安全网络登陆-29025|安全网络登陆-39026|安全网络登陆-49101|Bacula控制器9102|Bacula文件后台9103|Bacula存储邮件后台9111|DragonIDS控制台9217|FSC通讯端口9281|软件传送端口19282|软件传送端口29346|C技术监听9400|木马Incommand 1.0开放此端口9401|木马Incommand 1.0开放此端口9402|木马Incommand 1.0开放此端口9594|信息系统9595|Ping Discovery服务9800|WebDav源端口9801|Sakura脚本转移协议-29802|WebDAV Source TLS/SSL9872|木马Portal of Doom开放此端口9873|木马Portal of Doom开放此端口9874|木马Portal of Doom开放此端口9875|木马Portal of Doom开放此端口9899|木马InIkiller开放此端口9909|域名时间9911|SYPECom传送协议9989|木马iNi-Killer开放此端口9990|OSM Applet程序服务器9991|OSM事件服务器10000|网络数据管理协议10001|SCP构造端口10005|安全远程登陆10008|Octopus多路器10067|木马iNi-Killer开放此端口10113|NetIQ端点10115|NetIQ端点10116|NetIQVoIP鉴定器10167|木马iNi-Killer开放此端口11000|木马SennaSpy开放此端口11113|金山词霸开放此端口11233|木马Progenic trojan开放此端口12076|木马Telecommando开放此端口12223|木马Hack&apos;99 KeyLogger开放此端口12345|木马NetBus1.60/1.70、GabanBus开放此端口12346|木马NetBus1.60/1.70、GabanBus开放此端口12361|木马Whack-a-mole开放此端口13223|PowWow 客户端，是Tribal Voice的聊天程序13224|PowWow 服务器，是Tribal Voice的聊天程序16959|木马Subseven开放此端口16969|木马Priority开放此端口17027|外向连接19191|木马蓝色火焰开放此端口20000|木马Millennium开放此端口20001|木马Millennium开放此端口20034|木马NetBus Pro开放此端口21554|木马GirlFriend开放此端口22222|木马Prosiak开放此端口23444|木马网络公牛开放此端口23456|木马Evil FTP、Ugly FTP开放此端口25793|Vocaltec地址服务器26262|K3软件-服务器26263|K3软件客户端26274|木马Delta开放此端口27374|木马Subseven 2.1开放此端口30100|木马NetSphere开放此端口30129|木马Masters Paradise开放此端口30303|木马Socket23开放此端口30999|木马Kuang开放此端口31337|木马BO(Back orifice)开放此端口31338|木马BO(Back orifice)，DeepBO开放此端口31339|木马NetSpy DK开放此端口31666|木马BOWhack开放此端口31789|Hack-a-tack32770|sun solaris RPC服务开放此端口33333|木马Prosiak开放此端口33434|路由跟踪34324|木马Tiny Telnet Server、BigGluck、TN开放此端口36865|KastenX软件端口38201|Galaxy7软件数据通道39681|TurboNote默认端口40412|木马The Spy开放此端口40421|木马Masters Paradise开放此端口40422|木马Masters Paradise开放此端口40423|木马Masters Paradise开放此端口40426|木马Masters Paradise开放此端口40843|CSCC 防火墙43210|木马SchoolBus 1.0/2.0开放此端口43190|IP-PROVISION44321|PCP服务器(pmcd)44322|PCP服务器(pmcd)代理44334|微型个人防火墙端口44442|ColdFusion软件端口44443|ColdFusion软件端口44445|木马Happypig开放此端口45576|E代时光专业代理开放此端口47262|木马Delta开放此端口47624|Direct Play服务器47806|ALC协议48003|Nimbus网关50505|木马Sockets de Troie开放此端口50766|木马Fore开放此端口53001|木马Remote Windows Shutdown开放此端口54320|木马bo2000开放此端口54321|木马SchoolBus 1.0/2.0开放此端口61466|木马Telecommando开放此端口65000|木马Devil 1.03开放此端口65301|PC Anywhere软件开放端口","categories":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://chanran.github.io/categories/计算机知识/"}],"tags":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://chanran.github.io/tags/计算机知识/"}],"keywords":[{"name":"计算机知识","slug":"计算机知识","permalink":"https://chanran.github.io/categories/计算机知识/"}]},{"title":"模拟银行账户","slug":"simulate-bank-account","date":"2016-12-16T08:08:06.000Z","updated":"2016-12-16T08:12:52.515Z","comments":true,"path":"2016/12/16/simulate-bank-account/","link":"","permalink":"https://chanran.github.io/2016/12/16/simulate-bank-account/","excerpt":"","text":"题目描述前面创建了Account类来建模银行账户： （1）一个名为id的int型数据域，表示账户的身份号。 （2）一个名为balance的double型的数据域，表示账面余额。 （3）一个名为annualInterestRate的double型数据域，保存当前年利率。 （4）一个无参的构造函数，创建一个缺省的账户，其数据域id为0，balance为0，annualInterestRate为0。 （5）id、balance和annualInterestRate的访问器和更改器函数。 一个账户有账号、余额、年利率和账户创建时间等属性，还有存款和取款函数。创建它的两个派生类——支票账户和储蓄账户，前者有一个透支额度，后者不允许透支。定义Account类的一个常量虚函数toString（），并在派生类覆盖它，用来以字符串形式返回账号的余额。 画出这些类的UML图，实现该类，并编写一个测试程序，它创建一个Account、一个SavingsAccount和一个CheckingAccount账户，并调用它们的toString（）函数。 C++代码Account.h123456789101112131415161718192021222324252627282930313233343536//// Created by blue on 16-12-8.//#ifndef CHECKINGACCOUNTCLASS_ACCOUNT_H#define CHECKINGACCOUNTCLASS_ACCOUNT_H#include&lt;string&gt;class Account &#123;private: int id; double balance; double annualInterestRate;public: Account(); virtual std::string toString();public: int getId(); void setId(int id); double getBalance(); void setBalance(double balance); double getAnnualInterestRate(); void setAnnualInterestRate(double annualInterestRate);&#125;;#endif //CHECKINGACCOUNTCLASS_ACCOUNT_H account.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by blue on 16-12-8.//#include &quot;iostream&quot;#include &quot;sstream&quot;#include &quot;Account.h&quot;Account::Account() &#123; Account::id = 0; Account::balance = 0; Account::annualInterestRate = 0;&#125;int Account::getId() &#123; return id;&#125;void Account::setId(int id) &#123; Account::id = id;&#125;double Account::getBalance() &#123; return balance;&#125;void Account::setBalance(double balance) &#123; Account::balance = balance;&#125;double Account::getAnnualInterestRate() &#123; return annualInterestRate;&#125;void Account::setAnnualInterestRate(double annualInterestRate) &#123; Account::annualInterestRate = annualInterestRate;&#125;std::string Account:: toString()&#123; std::ostringstream ostring; ostring &lt;&lt; &quot;Account:&quot; &lt;&lt; Account::getId() &lt;&lt; &quot; balance:&quot; &lt;&lt; Account::getBalance(); return ostring.str();&#125;; SavingsAccount.h12345678910111213141516171819202122//// Created by blue on 16-12-8.//#ifndef CHECKINGACCOUNTCLASS_SAVINGSACCOUNT_H#define CHECKINGACCOUNTCLASS_SAVINGSACCOUNT_H#include &lt;string&gt;#include &quot;Account.h&quot;class SavingsAccount : public Account &#123;private: bool allowedOverdraft; std::string createAt;public: std::string toString() override; bool deposit(int id,double money); bool withdrawal(int id,double money);public: SavingsAccount(); const std::string &amp;getCreateAt() const; bool isAllowedOverdraft() const;&#125;;#endif //CHECKINGACCOUNTCLASS_SAVINGSACCOUNT_H SavingsAccount.cpp123456789101112131415161718192021222324252627282930313233343536373839//// Created by blue on 16-12-8.//#include &quot;iostream&quot;#include &quot;sstream&quot;#include &quot;SavingsAccount.h&quot;#include &quot;Date.h&quot;bool SavingsAccount::deposit(int id,double money)&#123; if (id == SavingsAccount::getId())&#123; SavingsAccount::setBalance(SavingsAccount::getBalance()+money); return true; &#125; return false;&#125;bool SavingsAccount::withdrawal(int id,double money)&#123; if (id == SavingsAccount::getId())&#123; if (SavingsAccount::getBalance() &lt; money)&#123; return false; &#125;else&#123; SavingsAccount::setBalance(SavingsAccount::getBalance()-money); return true; &#125; &#125; return false;&#125;const std::string &amp;SavingsAccount::getCreateAt() const &#123; return createAt;&#125;SavingsAccount::SavingsAccount() &#123; SavingsAccount::createAt = DateTime::currentTime();&#125;bool SavingsAccount::isAllowedOverdraft() const &#123; return allowedOverdraft;&#125;std::string SavingsAccount:: toString()&#123; std::ostringstream ostring; ostring &lt;&lt; &quot;Account:&quot; &lt;&lt; SavingsAccount::getId() &lt;&lt; &quot; balance:&quot; &lt;&lt; SavingsAccount::getBalance() &lt;&lt; &quot; CreateAt:&quot; &lt;&lt; SavingsAccount::getCreateAt(); return ostring.str();&#125;; CheckingAccount.h123456789101112131415161718192021222324//// Created by blue on 16-12-8.//#ifndef CHECKINGACCOUNTCLASS_CHECKINGACCOUNT_H#define CHECKINGACCOUNTCLASS_CHECKINGACCOUNT_H#include &quot;Account.h&quot;class CheckingAccount : public Account &#123;private: bool allowedOverdraft; double overdraft; std::string createAt;public: std::string toString() override; bool deposit(int id,double money); bool withdrawal(int id,double money);public: CheckingAccount(); const std::string &amp;getCreateAt() const; bool isAllowedOverdraft() const; double getOverdraft() const; void setOverdraft(double overdraft);&#125;;#endif //CHECKINGACCOUNTCLASS_CHECKINGACCOUNT_H CheckingAccount.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by blue on 16-12-8.//#include &quot;iostream&quot;#include &quot;sstream&quot;#include &quot;CheckingAccount.h&quot;#include &quot;Date.h&quot;bool CheckingAccount::deposit(int id,double money)&#123; if (id == CheckingAccount::getId())&#123; CheckingAccount::setBalance(CheckingAccount::getBalance()+money); return true; &#125; return false;&#125;bool CheckingAccount::withdrawal(int id,double money)&#123; if (id == CheckingAccount::getId())&#123; if (CheckingAccount::getBalance()-money &lt;= (-CheckingAccount::getOverdraft()))&#123; return false; &#125;else&#123; CheckingAccount::setBalance(CheckingAccount::getBalance()-money); return true; &#125; &#125; return false;&#125;const std::string &amp;CheckingAccount::getCreateAt() const &#123; return createAt;&#125;CheckingAccount::CheckingAccount() &#123; CheckingAccount::overdraft = 10000; CheckingAccount::createAt = DateTime::currentTime();&#125;bool CheckingAccount::isAllowedOverdraft() const &#123; return allowedOverdraft;&#125;double CheckingAccount::getOverdraft() const &#123; return CheckingAccount::overdraft;&#125;void CheckingAccount::setOverdraft(double overdraft) &#123; CheckingAccount::overdraft = overdraft;&#125;std::string CheckingAccount:: toString()&#123; std::ostringstream ostring; ostring &lt;&lt; &quot;Account:&quot; &lt;&lt; CheckingAccount::getId() &lt;&lt; &quot; balance:&quot; &lt;&lt; CheckingAccount::getBalance() &lt;&lt; &quot; CreateAt:&quot; &lt;&lt; CheckingAccount::getCreateAt(); return ostring.str();&#125;; Date.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by blue on 16-12-8.//#ifndef CHECKINGACCOUNTCLASS_DATE_H#define CHECKINGACCOUNTCLASS_DATE_H#include &lt;ctime&gt;#include &lt;string&gt;#include &lt;type_traits&gt;class DateTime &#123;public: template&lt;typename T&gt; static std::string convert(time_t t) &#123; return time2string(t); &#125; template&lt;typename T&gt; static time_t convert(const std::string&amp; timeStr) &#123; return string2time(timeStr); &#125; static std::string currentTime() &#123; return time2string(time(nullptr)); &#125;private: static std::string time2string(time_t t) &#123; struct tm* tmNow = localtime(&amp;t); char timeStr[sizeof(&quot;yyyy-mm-dd hh:mm:ss&quot;)] = &#123;&apos;\\0&apos;&#125;; std::strftime(timeStr, sizeof(timeStr), &quot;%Y-%m-%d %H:%M:%S&quot;, tmNow); return timeStr; &#125; static time_t string2time(const std::string&amp; timeStr) &#123; struct tm stTm; sscanf(timeStr.c_str(), &quot;%d-%d-%d %d:%d:%d&quot;, &amp;(stTm.tm_year), &amp;(stTm.tm_mon), &amp;(stTm.tm_mday), &amp;(stTm.tm_hour), &amp;(stTm.tm_min), &amp;(stTm.tm_sec)); stTm.tm_year -= 1900; stTm.tm_mon--; stTm.tm_isdst = -1; return mktime(&amp;stTm); &#125;&#125;;#endif //CHECKINGACCOUNTCLASS_DATE_H main.cpp12345678910111213141516#include &lt;iostream&gt;#include &quot;CheckingAccount.h&quot;#include &quot;SavingsAccount.h&quot;using namespace std;int main() &#123; SavingsAccount savingsAccount; CheckingAccount checkingAccount; cout &lt;&lt; &quot;SavingsAccount:&quot; &lt;&lt; savingsAccount.toString() &lt;&lt; endl; cout &lt;&lt; &quot;CheckingAccount&quot; &lt;&lt; checkingAccount.toString() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}]},{"title":"分割和合并文件","slug":"split-merge-file","date":"2016-12-16T08:04:24.000Z","updated":"2016-12-16T08:17:07.831Z","comments":true,"path":"2016/12/16/split-merge-file/","link":"","permalink":"https://chanran.github.io/2016/12/16/split-merge-file/","excerpt":"","text":"题目描述假设要备份一个巨大的文件（比如10GB AVI文件）到CD-R，可以把文件分割成几个小的文件，然后逐个备份。编写一个实用程序，它能将大文件分割成小文件。程序提示用户输入原文件名和每个小文件的字节数。下面是样例运行： 1234567Enter a source file name: c:\\exercise.zip ~EnterEnter the number of bytes in each smaller file: 9343400 ~EnterFile c:\\exercise.zip.0 producedFile c:\\exercise.zip.1 producedFile c:\\exercise.zip.2 producedFile c:\\exercise.zip.3 producedSplit Done 编写一个实用程序，合并文件到一个新的文件。程序提示用户输入源文件的个数、每个源文件的名字及目标文件名字。下面是样例运行： 1234567Enter the number of source files: 4 ~EnterEnter a source file: c:\\exercise.zip.0 ~EnterEnter a source file: c:\\exercise.zip.1 ~EnterEnter a source file: c:\\exercise.zip.2 ~EnterEnter a source file: c:\\exercise.zip.3 ~EnterEnter a target file: c:\\temp.zip ~EnterCombine Done C++代码main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace std;void splitFile(string path,long long smallFileBytes)&#123; fstream sourceFile(path.c_str(),ios::in|ios::binary); if (sourceFile.fail())&#123; cout &lt;&lt; &quot;打开文件失败！&quot; &lt;&lt; endl; exit(1); &#125; int numberOfFile = 0; char readBuffer[smallFileBytes]; while(!sourceFile.eof())&#123; string smallFileName = path; //应该需要分割/才对，可是没时间弄了 if (sourceFile.good())&#123; numberOfFile++; sourceFile.read(readBuffer,smallFileBytes); readBuffer[sourceFile.gcount()] = &apos;\\0&apos;; //可能没有写完整个readBuffer数组 ostringstream ostring; ostring &lt;&lt; smallFileName &lt;&lt; numberOfFile; smallFileName = ostring.str(); fstream resultFile(smallFileName.c_str(),ios::out | ios::binary); resultFile.write(readBuffer,sourceFile.gcount()); cout &lt;&lt; &quot;File &quot; &lt;&lt; smallFileName &lt;&lt; &quot; produced.&quot; &lt;&lt; endl; &#125; &#125; cout &lt;&lt; &quot;Split Done.&quot; &lt;&lt; endl; sourceFile.close();&#125;void mergeFile(int numOfFiles,string* fileArr,string resultFileName)&#123; fstream resultFile(resultFileName.c_str(), ios::out | ios::binary | ios::app); char* readBuffer; for (int i = 0; i &lt; numOfFiles; i++)&#123; fstream sourceFile(fileArr[i].c_str(),ios::in | ios::binary); sourceFile.seekg(0,ios::end); long smallFileLength = sourceFile.tellg(); sourceFile.seekg(0,ios::beg); readBuffer = new char[smallFileLength]; sourceFile.read(readBuffer,smallFileLength); sourceFile.close(); resultFile.write(readBuffer,smallFileLength); &#125; resultFile.close(); cout &lt;&lt; &quot;Combine Done&quot; &lt;&lt; endl;&#125;int main() &#123; string path = &quot;&quot;; long long smallFileBytes; cout &lt;&lt; &quot;Enter a source file name: &quot;; cin &gt;&gt; path; cout &lt;&lt; &quot;Enter the number of bytes in each smaller file: &quot;; cin &gt;&gt; smallFileBytes; splitFile(path,smallFileBytes); int numOfFiles = 0; cout &lt;&lt; &quot;Enter the number of source files:&quot;; cin &gt;&gt; numOfFiles; string fileArr[numOfFiles]; cout &lt;&lt; &quot;Enter the name of each source file:&quot;; for (int i = 0; i &lt; numOfFiles; i++)&#123; cin &gt;&gt; fileArr[i]; &#125; cout &lt;&lt; &quot;Enter the name of merged file:&quot;; string resultFileName = &quot;&quot;; cin &gt;&gt; resultFileName; mergeFile(numOfFiles,fileArr,resultFileName); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}]},{"title":"Complex类，运算符重载","slug":"operator-overloading","date":"2016-12-16T07:53:07.000Z","updated":"2016-12-16T07:59:23.321Z","comments":true,"path":"2016/12/16/operator-overloading/","link":"","permalink":"https://chanran.github.io/2016/12/16/operator-overloading/","excerpt":"","text":"题目描述复数形式是a+bi，其中a和b是实数，i是。a和b分别被称为复数的实部和虚部。可以使用下列公式实现复数的加、减、乘、除： a + bi + c + di = (a + c) + (b + d) i a + bi - (c + di) = (a - c) + (b - d) i (a + bi) * (c + di) = (ac - bd) + (bc + ad) i (a + bi) / (c + di) = (ac + bd) / (c2 + d2) + (bc - ad) i /(c2 + d2) 使用下面公式也可以获得复数的绝对值： |a+bi|=√(a^2+b^2) 设计一个名为Complex的复数类，它可以用函数add、subtract、multiply、divide和abs实现复数的加、减、乘、除和取绝对值。toString函数实现以字符串形式表示的复数a+bi。如果b是0，只返回a。 该类有三个构造函数Complex (a, b)、Complex (a)和Complex ( )。Complex ( )生成一个表示原点的复数对象，Complex (a)生成一个b值为0的复数对象。函数getRealPart ( )和getImaginaryPart ( )分别返回复数的实部和虚部。 重载运算符+，-，，/，+=，-=，=，/=，[ ]，一元+和-，前缀++和–，后缀++和–，&lt;&lt;，&gt;&gt;。 以非成员函数形式重载+，-，*，/。重载[ ]，使得[0]返回a，[1]返回b。编写一个测试程序：当用户输入两个复数后，程序显示它们的加、减、乘、除操作的结果。样例输出如下： 1234567Enter the first complex number: 3.5 5.5 ~EnterEnter the second complex number: -3.5 1 ~Enter(3.5 + 5.5i) + (-3.5 + 1.0i) = 0.0 + 6.5i(3.5 + 5.5i) - (-3.5 + 1.0i) = 7.0 + 4.5i(3.5 + 5.5i) * (-3.5 + 1.0i) = -17.75 + -15.75i(3.5 + 5.5i) / (-3.5 + 1.0i) = -0.5094 + -1.7i|3.5 + 5.5i| = 6.519202405202649 C++代码Complex.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// Created by blue on 16-12-9.//#ifndef COMPLEXCLASS_COMPLEX_H#define COMPLEXCLASS_COMPLEX_H#include &quot;iostream&quot;#include &quot;sstream&quot;#include &lt;string&gt;class Complex &#123;private: double realPart; double virtualPart;public: Complex add(const Complex &amp;c); Complex subtract(const Complex &amp;c); Complex multiply(const Complex &amp;c); Complex divide(const Complex &amp;c); double abs(); std::string toString();public: Complex operator+(const Complex &amp;c); Complex operator-(const Complex &amp;c); Complex operator*(const Complex &amp;c); Complex operator/(const Complex &amp;c); Complex operator+=(const Complex &amp;c); Complex operator-=(const Complex &amp;c); Complex operator*=(const Complex &amp;c); Complex operator/=(const Complex &amp;c); double operator[](const int &amp;index); Complex operator+(); Complex operator-(); Complex operator++(); //前置版本 Complex operator--(); //前置版本 Complex operator++(int t); //后置版本 Complex operator--(int t); //后置版本 friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os,const Complex &amp;c); //输出运算附 friend std::istream&amp; operator&gt;&gt;(std::istream &amp;is,Complex c); //输入运算符public: Complex(); Complex(double realPart); Complex(double realPart, double virtualPart); double getRealPart() const; void setRealPart(double realPart); double getVirtualPart() const; void setVirtualPart(double virtualPart);&#125;;#endif //COMPLEXCLASS_COMPLEX_H Complex.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197//// Created by blue on 16-12-9.//#include &quot;iostream&quot;#include &quot;sstream&quot;#include &quot;Complex.h&quot;#include &lt;math.h&gt;/*方法*/Complex Complex:: add(const Complex &amp;c)&#123; Complex temp; temp.setRealPart(Complex::getRealPart()+c.getRealPart()); temp.setVirtualPart(Complex::getVirtualPart()+c.getVirtualPart()); return temp;&#125;Complex Complex::subtract(const Complex &amp;c)&#123; Complex temp; temp.setRealPart(Complex::getRealPart()-c.getRealPart()); temp.setVirtualPart(Complex::getVirtualPart()-c.getVirtualPart()); return temp;&#125;Complex Complex::multiply(const Complex &amp;c)&#123; Complex temp; temp.setRealPart(Complex::getRealPart()*c.getRealPart()-Complex::getVirtualPart()*c.getVirtualPart()); temp.setVirtualPart(Complex::getVirtualPart()*c.getRealPart()+Complex::getRealPart()*c.getVirtualPart()); return temp;&#125;Complex Complex::divide(const Complex &amp;c)&#123; Complex temp; temp.setRealPart((Complex::getRealPart()*c.getRealPart()+Complex::getVirtualPart()*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); temp.setVirtualPart((Complex::getVirtualPart()*c.getRealPart()-Complex::getRealPart()*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); return temp;&#125;double Complex::abs()&#123; return sqrt(pow(Complex::getRealPart(),2)+pow(Complex::getVirtualPart(),2));&#125;std::string Complex::toString()&#123; std::ostringstream ostring; if (Complex::getVirtualPart() == 0)&#123; ostring &lt;&lt; Complex::getRealPart(); &#125;else if (Complex::getVirtualPart() &lt; 0)&#123; ostring &lt;&lt; Complex::getRealPart() &lt;&lt; &quot;-&quot; &lt;&lt; fabs(Complex::getVirtualPart()) &lt;&lt; &quot;i&quot;; &#125;else&#123; ostring &lt;&lt; Complex::getRealPart() &lt;&lt; &quot;+&quot; &lt;&lt; Complex::getVirtualPart() &lt;&lt; &quot;i&quot;; &#125; return ostring.str();&#125;/*运算符重载*/Complex Complex::operator+(const Complex &amp;c)&#123; Complex tmp; tmp.setRealPart(Complex::getRealPart()+c.getRealPart()); tmp.setVirtualPart(Complex::getVirtualPart()+c.getVirtualPart()); return tmp;&#125;Complex Complex::operator-(const Complex &amp;c)&#123; Complex tmp; tmp.setRealPart(Complex::getRealPart()-c.getRealPart()); tmp.setVirtualPart(Complex::getVirtualPart()-c.getVirtualPart()); return tmp;&#125;Complex Complex::operator*(const Complex &amp;c)&#123; Complex tmp(Complex::getRealPart(),Complex::getVirtualPart()); tmp.setRealPart(Complex::getRealPart()*c.getRealPart()-Complex::getVirtualPart()*c.getVirtualPart()); tmp.setVirtualPart(Complex::getVirtualPart()*c.getRealPart()+Complex::getRealPart()*c.getVirtualPart()); return tmp;&#125;Complex Complex::operator/(const Complex &amp;c)&#123; Complex temp; temp.setRealPart((Complex::getRealPart()*c.getRealPart()+Complex::getVirtualPart()*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); temp.setVirtualPart((Complex::getVirtualPart()*c.getRealPart()-Complex::getRealPart()*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); return temp;&#125;Complex Complex::operator+=(const Complex &amp;c)&#123; double a = Complex::getRealPart(); double b = Complex::getVirtualPart(); Complex::setRealPart((a*c.getRealPart()+b*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); Complex::setVirtualPart((b*c.getRealPart()-a*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); return *this;&#125;Complex Complex::operator-=(const Complex &amp;c)&#123; double a = Complex::getRealPart(); double b = Complex::getVirtualPart(); Complex::setRealPart(a-c.getRealPart()); Complex::setVirtualPart(b-c.getVirtualPart()); return *this;&#125;Complex Complex::operator*=(const Complex &amp;c)&#123; double a = Complex::getRealPart(); double b = Complex::getVirtualPart(); Complex::setRealPart(a*c.getRealPart()-b*c.getVirtualPart()); Complex::setVirtualPart(b*c.getRealPart()+a*c.getVirtualPart()); return *this;&#125;Complex Complex::operator/=(const Complex &amp;c)&#123; double a = Complex::getRealPart(); double b = Complex::getVirtualPart(); Complex::setRealPart((a*c.getRealPart()+b*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); Complex::setVirtualPart((a*c.getRealPart()-b*c.getVirtualPart())/(pow(c.getRealPart(),2)+pow(c.getVirtualPart(),2))); return *this;&#125;double Complex::operator[](const int &amp;index)&#123; if (index == 0)&#123; return Complex::getRealPart(); &#125;else if(index == 1)&#123; return Complex::getVirtualPart(); &#125;else&#123; std::cout &lt;&lt; &quot;Invalid Index.&quot; &lt;&lt; std::endl; &#125;&#125;Complex Complex::operator+()&#123; Complex::setRealPart(fabs(Complex::getRealPart())); Complex::setVirtualPart(fabs(Complex::getVirtualPart())); return *this;&#125;Complex Complex::operator-()&#123; Complex::setRealPart(-Complex::getRealPart()); Complex::setVirtualPart(-Complex::getVirtualPart()); return *this;&#125;Complex Complex::operator++()&#123; //前置版本 Complex::setRealPart(Complex::getRealPart()+1); Complex::setVirtualPart(Complex::getRealPart()+1); return *this;&#125;Complex Complex::operator--()&#123; //前置版本 Complex::setRealPart(Complex::getRealPart()-1); Complex::setVirtualPart(Complex::getRealPart()-1); return *this;&#125;Complex Complex::operator++(int t)&#123; //后置版本 Complex tmp(Complex::getRealPart(),Complex::getVirtualPart()); this-&gt;setRealPart(this-&gt;getRealPart()+1); this-&gt;setVirtualPart(this-&gt;getVirtualPart()+1); return tmp;&#125;Complex Complex::operator--(int t)&#123; //后置版本 Complex tmp(Complex::getRealPart(),Complex::getVirtualPart()); this-&gt;setRealPart(this-&gt;getRealPart()-1); this-&gt;setVirtualPart(this-&gt;getVirtualPart()-1); return tmp;&#125;/*输入输出重载*/std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os,const Complex &amp;c)&#123; //输出运算符 if (c.getVirtualPart() &gt; 0)&#123; os &lt;&lt; c.getRealPart() &lt;&lt; &quot;+&quot; &lt;&lt; c.getVirtualPart() &lt;&lt; &quot;i&quot;; &#125;else if(c.getVirtualPart() == 0)&#123; os &lt;&lt; c.getRealPart(); &#125;else&#123; os &lt;&lt; c.getRealPart() &lt;&lt; &quot;-&quot; &lt;&lt; fabs(c.getVirtualPart()) &lt;&lt; &quot;i&quot;; &#125; return os;&#125;std::istream&amp; operator&gt;&gt;(std::istream &amp;is,Complex c)&#123; //输入运算符 double t1,t2; is &gt;&gt; t1 &gt;&gt; t2; c.setRealPart(t1); c.setVirtualPart(t2); return is;&#125;/*构造函数,getter,setter*/Complex::Complex() &#123; Complex::realPart = 0; Complex::virtualPart = 0;&#125;Complex::Complex(double realPart) : realPart(realPart) &#123; Complex::realPart = realPart; Complex::virtualPart = 0;&#125;Complex::Complex(double realPart, double virtualPart) : realPart(realPart), virtualPart(virtualPart) &#123; Complex::realPart = realPart; Complex::virtualPart = virtualPart;&#125;double Complex::getRealPart() const &#123; return realPart;&#125;void Complex::setRealPart(double realPart) &#123; Complex::realPart = realPart;&#125;double Complex::getVirtualPart() const &#123; return virtualPart;&#125;void Complex::setVirtualPart(double virtualPart) &#123; Complex::virtualPart = virtualPart;&#125; main.cpp1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &quot;Complex.h&quot;using namespace std;int main()&#123; double a0,a1; double b0,b1; cout &lt;&lt; &quot;Enter the first complex number: &quot; &lt;&lt; endl; cin &gt;&gt; a0 &gt;&gt; a1; cout &lt;&lt; &quot;Enter the second complex number:&quot; &lt;&lt; endl; cin &gt;&gt; b0 &gt;&gt; b1; Complex a(a0,a1); Complex b(b0,b1); cout &lt;&lt; &quot;(&quot; &lt;&lt; a.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; + &quot; &lt;&lt; &quot;(&quot; &lt;&lt; b.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; = &quot; &lt;&lt; (a+b).toString() &lt;&lt; endl; cout &lt;&lt; &quot;(&quot; &lt;&lt; a.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; - &quot; &lt;&lt; &quot;(&quot; &lt;&lt; b.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; = &quot; &lt;&lt; (a-b).toString() &lt;&lt; endl; cout &lt;&lt; &quot;(&quot; &lt;&lt; a.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; * &quot; &lt;&lt; &quot;(&quot; &lt;&lt; b.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; = &quot; &lt;&lt; (a*b).toString() &lt;&lt; endl; cout &lt;&lt; &quot;(&quot; &lt;&lt; a.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; / &quot; &lt;&lt; &quot;(&quot; &lt;&lt; b.toString() &lt;&lt; &quot;)&quot; &lt;&lt; &quot; = &quot; &lt;&lt; (a/b).toString() &lt;&lt; endl; cout &lt;&lt; &quot;|&quot; &lt;&lt; a.toString() &lt;&lt; &quot;|&quot; &lt;&lt; &quot; = &quot; &lt;&lt; a.abs() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}]},{"title":"寻找最大子方阵","slug":"find-largest-matrix-block","date":"2016-12-16T07:46:00.000Z","updated":"2016-12-16T08:00:57.906Z","comments":true,"path":"2016/12/16/find-largest-matrix-block/","link":"","permalink":"https://chanran.github.io/2016/12/16/find-largest-matrix-block/","excerpt":"","text":"题目描述给定一个元素为0或1的方阵，编写一个程序，找出其中最大的子方阵，使得该子方阵的元素都是1。程序先提示用户输入矩阵的行数，然后提示用户输入矩阵内容，打印输出最大子方阵的第一个元素的位置以及最大子方阵的行数。假定矩阵最多有100行。下面是样例运行： 12345678Enter the number of rows for the matrix: 5 ~EnterEnter the matrix row by row:1 0 1 0 1 ~Enter1 1 1 0 1 ~Enter1 0 1 1 1 ~Enter1 0 1 1 1 ~Enter1 0 1 1 1 ~EnterThe maximum square submatrix is at (2，2) with size 3 程序中应实现下面的函数来寻找最大子方阵：vector findLargestBlock (const vector","categories":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/tags/C/"}],"keywords":[{"name":"C++","slug":"C","permalink":"https://chanran.github.io/categories/C/"}]},{"title":"Uncaught TypeError: _react2.default.render is not a function 解决方法","slug":"Uncaught-TypeError-react2-default-render-is-not-a-function","date":"2016-12-11T07:39:25.000Z","updated":"2016-12-16T08:21:04.488Z","comments":true,"path":"2016/12/11/Uncaught-TypeError-react2-default-render-is-not-a-function/","link":"","permalink":"https://chanran.github.io/2016/12/11/Uncaught-TypeError-react2-default-render-is-not-a-function/","excerpt":"","text":"在浏览器上报错Uncaught TypeError: _react2.default.render is not a function原因 React版本过高，不支持React.render()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&apos;use strict&apos;;import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import LocalDb from &apos;localDb&apos;;import TodoHeader from &apos;./TodoHeader&apos;;import TodoMain from &apos;./TodoMain&apos;;import TodoFooter from &apos;./TodoFooter&apos;;/** * 从上面的渲染（render）方法可以看出，组件的结构分为三部分，就是上中下。 * 上面的TodoHeader是用来输入任务的地方，中间的TodoMain是用来展示任务列表的, * 下面的TodoFooter提供一些特殊的方法，比如全选、删除等。 */class App extends React.Component&#123; constructor()&#123; super(); this.db = new LocalDb(&apos;ReactDemo&apos;); //定义组件状态 this.state =&#123; todos:this.db.get(&apos;todos&apos;) || [], isAllChecked:false &#125;; &#125;// 判断是否所有任务的状态都完成，同步底部的全选框 allChecked()&#123; let isAllChecked = false; if (this.state.todos.every(todo =&gt; todo.isDone))&#123; isAllChecked = true; &#125; this.setState(&#123; todos:this.state.todos, isAllChecked:isAllChecked &#125;); &#125;// 添加任务，是传递给Header组件的方法 addTodo(todoItem)&#123; this.state.todos.push(todoItem); this.db.set(&apos;todos&apos;,this.state.todos); this.allChecked(); &#125;// 删除当前的任务，传递给TodoItem的方法 deleteTodo(index)&#123; this.state.todos.splice(index,1); this.setState(&#123;todos:this.state.todos&#125;); this.db.set(&apos;todos&apos;,this.state.todos); &#125;// 清除已完成的任务，传递给Footer组件的方法 clearDone()&#123; let todos = this.state.todos.filter(todo =&gt; !todo.isDone); this.setState(&#123; todos:todos, isAllChecked:false &#125;); this.db.set(&apos;todos&apos;,todos); &#125;// 改变任务状态，传递给TodoItem和Footer组件的方法 changeTodoState(index,isDone,isChangeAll=false)&#123; if(isChangeAll)&#123; this.setState(&#123; todos:this.state.todos.map( (todo) =&gt; &#123; todo.isDone = isDone; return todo; &#125;), isAllChecked:isDone &#125;); &#125;else&#123; this.state.todos[index].isDone = isDone; this.allChecked(); &#125; this.db.set(&apos;todos&apos;,this.state.todos); &#125;//组件渲染方法 render()&#123; let info = &#123; isAllChecked:this.state.isAllChecked, todoCount:this.state.todos.length || 0, todoDoneCount:(this.state.todos &amp;&amp; this.state.todos.filter((todo)=&gt;todo.isDone)).length || 0 &#125;; return ( &lt;div className=&quot;todo-wrap&quot;&gt; &lt;TodoHeader addTodo=&#123;this.addTodo.bind(this)&#125; /&gt; &lt;TodoMain todos=&#123;this.state.todos&#125; deleteTodo=&#123;this.deleteTodo.bind(this)&#125; changeTodoState=&#123;this.changeTodoState.bind(this)&#125; /&gt; &lt;TodoFooter &#123;...info&#125; changeTodoState=&#123;this.changeTodoState.bind(this)&#125; clearDone=&#123;this.clearDone.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;React.render(&lt;App/&gt;,document.getElementById(&apos;app&apos;)); //这句的问题 解决方法 降低React版本（不推荐） 将最后一句React.render(&lt;App/&gt;,document.getElementById(&#39;app&#39;));改成ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;app&#39;)); （如果没有引入react-dom是会报找不到ReactDOM方法的） 其实有关DOM操作的时候，都需要用ReactDOM来代替React。例如：这里也会报同样的错误 React.findDOMNode(this).style.background = &#39;#eee&#39;; 改成这样就好了 ReactDOM.findDOMNode(this).style.background = &#39;#eee&#39;;","categories":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/tags/react/"}],"keywords":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/categories/react/"}]},{"title":"webpack react 在浏览器报错:Uncaught ReferenceError: React is not defined","slug":"webpack-react-error-Uncaught-ReferenceError-React-is-not-defined","date":"2016-12-11T07:21:25.000Z","updated":"2016-12-11T07:29:49.893Z","comments":true,"path":"2016/12/11/webpack-react-error-Uncaught-ReferenceError-React-is-not-defined/","link":"","permalink":"https://chanran.github.io/2016/12/11/webpack-react-error-Uncaught-ReferenceError-React-is-not-defined/","excerpt":"","text":"问题出在webpack.config.js内容1234567891011121314151617181920&apos;use strict&apos;;module.exports = &#123; entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:8080&apos;, &apos;./src/components/index/app.js&apos; ], output: &#123; path: &apos;./build/&apos;, filename: &apos;bundle.js&apos; &#125;, externals: &#123; &apos;react&apos;: &apos;React&apos; &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, loader: &apos;jsx!babel&apos;, include: /src/&#125; ] &#125;&#125;; 这里的externals:{&#39;react&#39;:&#39;React&#39;}会将React赋给交给windows.React.而且给commonJS的require(‘React’)用(注意不是require(‘react’))。 在代码里使用import而不是require的话就会在浏览器报错了。(请忽略长长的代码)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&apos;use strict&apos;;import React from &apos;react&apos;;import LocalDb from &apos;localDb&apos;;import TodoHeader from &apos;./TodoHeader&apos;;import TodoMain from &apos;./TodoMain&apos;;import TodoFooter from &apos;./TodoFooter&apos;;/** * 从上面的渲染（render）方法可以看出，组件的结构分为三部分，就是上中下。 * 上面的TodoHeader是用来输入任务的地方，中间的TodoMain是用来展示任务列表的, * 下面的TodoFooter提供一些特殊的方法，比如全选、删除等。 */class App extends React.Component&#123; constructor()&#123; super(); this.db = new LocalDb(&apos;ReactDemo&apos;); //定义组件状态 this.state =&#123; todos:this.db.get(&apos;todos&apos;) || [], isAllChecked:false &#125;; &#125;// 判断是否所有任务的状态都完成，同步底部的全选框 allChecked()&#123; let isAllChecked = false; if (this.state.todos.every(todo =&gt; todo.isDone))&#123; isAllChecked = true; &#125; this.setState(&#123; todos:this.state.todos, isAllChecked:isAllChecked &#125;); &#125;// 添加任务，是传递给Header组件的方法 addTodo(todoItem)&#123; this.state.todos.push(todoItem); this.db.set(&apos;todos&apos;,this.state.todos); this.allChecked(); &#125;// 删除当前的任务，传递给TodoItem的方法 deleteTodo(index)&#123; this.state.todos.splice(index,1); this.setState(&#123;todos:this.state.todos&#125;); this.db.set(&apos;todos&apos;,this.state.todos); &#125;// 清除已完成的任务，传递给Footer组件的方法 clearDone()&#123; let todos = this.state.todos.filter(todo =&gt; !todo.isDone); this.setState(&#123; todos:todos, isAllChecked:false &#125;); this.db.set(&apos;todos&apos;,todos); &#125;// 改变任务状态，传递给TodoItem和Footer组件的方法 changeTodoState(index,isDone,isChangeAll=false)&#123; if(isChangeAll)&#123; this.setState(&#123; todos:this.state.todos.map( (todo) =&gt; &#123; todo.isDone = isDone; return todo; &#125;), isAllChecked:isDone &#125;); &#125;else&#123; this.state.todos[index].isDone = isDone; this.allChecked(); &#125; this.db.set(&apos;todos&apos;,this.state.todos); &#125;//组件渲染方法 render()&#123; let info = &#123; isAllChecked:this.state.isAllChecked, todoCount:this.state.todos.length || 0, todoDoneCount:(this.state.todos &amp;&amp; this.state.todos.filter((todo)=&gt;todo.isDone)).length || 0 &#125;; return ( &lt;div className=&quot;todo-wrap&quot;&gt; &lt;TodoHeader addTodo=&#123;this.addTodo.bind(this)&#125; /&gt; &lt;TodoMain todos=&#123;this.state.todos&#125; deleteTodo=&#123;this.deleteTodo.bind(this)&#125; changeTodoState=&#123;this.changeTodoState.bind(this)&#125; /&gt; &lt;TodoFooter &#123;...info&#125; changeTodoState=&#123;this.changeTodoState.bind(this)&#125; clearDone=&#123;this.clearDone.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;React.render(&lt;App/&gt;,document.getElementById(&apos;app&apos;)); stackoverflow这里解释得更清楚 Uncaught ReferenceError: React is not defined","categories":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://chanran.github.io/tags/webpack/"}],"keywords":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/categories/react/"}]},{"title":"eslint react xxx is assigned a value but never used 的解决办法","slug":"eslint-react-xxx-is-assigned-a-value-but-never-used-solution","date":"2016-12-10T16:09:15.000Z","updated":"2016-12-16T08:27:35.055Z","comments":true,"path":"2016/12/11/eslint-react-xxx-is-assigned-a-value-but-never-used-solution/","link":"","permalink":"https://chanran.github.io/2016/12/11/eslint-react-xxx-is-assigned-a-value-but-never-used-solution/","excerpt":"","text":"ESLint中文翻译 ESLint 问题重现(定义了变量并使用了，但是eslint还是报定义过了但是未使用的错误)123456789101112import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;let Form = React.createClass(&#123; render: () =&gt; &#123; &lt; div className = &quot;form&quot; &gt; &lt; div className = &quot;form-title&quot; &gt; Simple Login Form &lt; /div&gt; &lt;div className=&quot;name-div&quot;&gt;&lt;label htmlFor=&quot;username&quot; className=&quot;name-label&quot;&gt;Name:&lt;/label &gt; &lt;input id=&quot;username&quot; className=&quot;name-input&quot; name=&quot;username&quot; type=&quot;text&quot;/&gt; &lt; /div&gt; &lt;div className=&quot;pwd-div&quot;&gt;&lt;label htmlFor=&quot;password&quot; className=&quot;pwd-label&quot;&gt;Password:&lt;/label &gt; &lt;input id=&quot;password&quot; className=&quot;pwd-input&quot; name=&quot;password&quot; type=&quot;password&quot;/&gt; &lt; /div&gt; &lt;/div &gt;; &#125;&#125;);ReactDOM.render(&lt;Form /&gt;,document.getElementById(&apos;loginForm&apos;)); 然后atom 的eslint报了no-unused-vars &#39;Form&#39; is assigned a value but never used.at line 4 col 5的错误。 比较麻烦的解决办法–每一行报错的地方都加一行注释在声明变量的当前行加上一条注释 // eslint-disable-line no-unused-vars 即是：123456789101112import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;let Form = React.createClass(&#123; // eslint-disable-line no-unused-vars render: () =&gt; &#123; &lt; div className = &quot;form&quot; &gt; &lt; div className = &quot;form-title&quot; &gt; Simple Login Form &lt; /div&gt; &lt;div className=&quot;name-div&quot;&gt;&lt;label htmlFor=&quot;username&quot; className=&quot;name-label&quot;&gt;Name:&lt;/label &gt; &lt;input id=&quot;username&quot; className=&quot;name-input&quot; name=&quot;username&quot; type=&quot;text&quot;/&gt; &lt; /div&gt; &lt;div className=&quot;pwd-div&quot;&gt;&lt;label htmlFor=&quot;password&quot; className=&quot;pwd-label&quot;&gt;Password:&lt;/label &gt; &lt;input id=&quot;password&quot; className=&quot;pwd-input&quot; name=&quot;password&quot; type=&quot;password&quot;/&gt; &lt; /div&gt; &lt;/div &gt;; &#125;&#125;);ReactDOM.render(&lt;Form /&gt;,document.getElementById(&apos;loginForm&apos;)); 比较暴力的解决方法–直接禁用变量声明但未使用的提示,但是也比较省心，不用加一堆注释设置.eslint.json(或者是yaml等)的”no-unused-vars”规则为禁用(0为禁用)。具体可以看这里12345&#123; &quot;rules&quot;:&#123; &quot;no-unused-vars&quot;:0 &#125;&#125;","categories":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/tags/react/"},{"name":"eslint","slug":"eslint","permalink":"https://chanran.github.io/tags/eslint/"}],"keywords":[{"name":"react","slug":"react","permalink":"https://chanran.github.io/categories/react/"}]},{"title":"写electron遇到的坑","slug":"写electron遇到的坑","date":"2016-12-07T16:37:28.000Z","updated":"2016-12-07T17:20:02.508Z","comments":true,"path":"2016/12/08/写electron遇到的坑/","link":"","permalink":"https://chanran.github.io/2016/12/08/写electron遇到的坑/","excerpt":"","text":"electron进程之间的通信渲染进程和主进程之间的通信 渲染进程和主进程之间通过ipc通信，渲染进程使用的是ipcRenderer,而主进程使用的是ipcMain。 渲染进程和渲染进程之间的通信 渲染进程和渲染进程之间的通信：渲染进程1-&gt;主进程-&gt;渲染进程2。 进程之间数据共享：IPC，HTML5 API(Storage API,IndexedDB)等注意不要犯的错:比如在进程1中改变过了ES6类1的静态属性，如果在进程2中require了这个类1，那么进程2只能得到进程1改变类1的静态属性之前的值。 IPC通信:可以使用Electron中提供的IPC系统。它在主进程中将一个对象储存为全局变量，然后可以通过remote模块操作它们 HTML5 API","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/categories/nodejs/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://chanran.github.io/tags/electron/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/tags/nodejs/"},{"name":"javascript","slug":"javascript","permalink":"https://chanran.github.io/tags/javascript/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/categories/nodejs/"}]},{"title":"写vuejs需要注意的地方","slug":"写vuejs需要注意的地方","date":"2016-12-06T10:36:11.000Z","updated":"2016-12-06T10:42:48.299Z","comments":true,"path":"2016/12/06/写vuejs需要注意的地方/","link":"","permalink":"https://chanran.github.io/2016/12/06/写vuejs需要注意的地方/","excerpt":"","text":"Vue的实例嵌套最高级的实例为主，低级的实例方法Vue的数组更新问题不能直接赋值数组，触发不了视图更新使用变异方法和非变异方法Vue对src属性的处理","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chanran.github.io/categories/javascript/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"https://chanran.github.io/tags/vuejs/"},{"name":"MVVM","slug":"MVVM","permalink":"https://chanran.github.io/tags/MVVM/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://chanran.github.io/categories/javascript/"}]},{"title":"ubuntu放wifi(热点)给安卓手机","slug":"ubuntu放wifi(热点)给安卓手机","date":"2016-11-30T01:19:38.000Z","updated":"2016-11-30T02:24:15.689Z","comments":true,"path":"2016/11/30/ubuntu放wifi(热点)给安卓手机/","link":"","permalink":"https://chanran.github.io/2016/11/30/ubuntu放wifi(热点)给安卓手机/","excerpt":"","text":"前言由于宿舍路由器坏了，手机流量急剧下降（刷twitter…)，所以只能出此下册（个人不太喜欢电脑放wifi）。 ubuntu16.04lts软件中心安装kde5-nm-connection-editor 注：ubuntu14.04lts该软件为kde5-nm-connection-editor。 在终端打开kde5-nm-connection-editor 注：ubuntu14.04lts:在终端输入kde-nm-connection-editor 添加无线(共享)连接 填写连接信息：连接名称，SSID,模式。设置热点密码 记得连接有线网络，不然是释放不了wifi(热点的),点击右上角网络连接的icon,选择连接隐藏网络，选择你设置的连接名称 点击连接 这里有点小问题：好像不能设置wifi安全性，连不上blue’wifi。没关系，我们可以另辟蹊径。 打开之后切换到Wi-Fi安全性的tab那里 都设置好了之后就拿去你手机连接你设置的热点吧～ 可能刚设置完，需要等几分钟才能生效的。 如果还是设置不好，那就参考下面的链接 Share Internet Connection With Android in Ubuntu 14.04 ubuntu14.04怎么建立wifi热点？","categories":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://chanran.github.io/categories/瞎折腾/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://chanran.github.io/tags/ubuntu/"},{"name":"wifi","slug":"wifi","permalink":"https://chanran.github.io/tags/wifi/"}],"keywords":[{"name":"瞎折腾","slug":"瞎折腾","permalink":"https://chanran.github.io/categories/瞎折腾/"}]},{"title":"electron开发跨平台桌面应用","slug":"electron开发跨平台桌面应用","date":"2016-11-29T15:49:23.000Z","updated":"2016-11-30T01:18:34.379Z","comments":true,"path":"2016/11/29/electron开发跨平台桌面应用/","link":"","permalink":"https://chanran.github.io/2016/11/29/electron开发跨平台桌面应用/","excerpt":"","text":"留坑====== 安装electron","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/categories/nodejs/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://chanran.github.io/tags/electron/"},{"name":"js","slug":"js","permalink":"https://chanran.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/tags/nodejs/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/categories/nodejs/"}]},{"title":"写nodejs时遇到的坑","slug":"写nodejs时遇到的坑","date":"2016-11-29T11:16:45.000Z","updated":"2016-12-16T08:15:19.207Z","comments":true,"path":"2016/11/29/写nodejs时遇到的坑/","link":"","permalink":"https://chanran.github.io/2016/11/29/写nodejs时遇到的坑/","excerpt":"","text":"坑一：模块require在html引入的js文件里require的时候是基于该html文件的。目录结构 12345src/ index.html js/ index.js test.js src/index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/js/index.js 12const test = require(&apos;./test&apos;);test(); src/js/test.js 123module.exports = function()&#123; console.log(&apos;you are require src/js/test.js&apos;);&#125; 用nodejs运行上面的代码，打开index.html，会报找不到./test模块的错误，将index.js的代码改成下面的就行了。 src/js/index.js 12const test = require(&apos;./js/test&apos;); //基于index.html所在目录下。test(); nodejs循环依赖（每种情况不同解决方法）。 定义： 当有require()模块循环时，模块返回的时候还没有执行完。即： a模块 require b模块，b模块也 require a模块。 官网例子: 1.当main.js先require a.js时，此时程序进入a.js执行require b.js，然后程序又进入b.js之后b.js尝试require a.js，此时就发现有问题, a.js返回了没有执行完的模块给b.js,即a.js执行到exports.done =false就返回给b.js了，所以在b.js里的a.js是没有执行完的。而如果是另一种情况，a.js是用module.exports出来的，那么b.js得到的是一个空对象object{}。（这里有点绕，有空画一张图出来比较好理解） a.js 123456console.log(&apos;a starting&apos;);exports.done = false;const b = require(&apos;./b.js&apos;);console.log(&apos;in a, b.done = %j&apos;, b.done);exports.done = true;console.log(&apos;a done&apos;); b.js 123456console.log(&apos;b starting&apos;);exports.done = false;const a = require(&apos;./a.js&apos;);console.log(&apos;in b, a.done = %j&apos;, a.done);exports.done = true;console.log(&apos;b done&apos;); main.js 1234console.log(&apos;main starting&apos;);const a = require(&apos;./a.js&apos;);const b = require(&apos;./b.js&apos;);console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done); 执行结果 12345678main startinga startingb startingin b, a.done = falseb donein a, b.done = truea donein main, a.done=true, b.done=true 2.基本同上，但是main.js有所改动。这里main.js先调用b.js。对比上面main.js先调用a.js。程序入口不一样，程序的执行顺序也不一样，结果也反过来了。 main.js 1234console.log(&apos;main starting&apos;);const b = require(&apos;./b.js&apos;); //对比之前的main.js，这里先调用b.jsconst a = require(&apos;./a.js&apos;);console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done); 执行结果 12345678main startingb startinga startingin a, b.done = falsea donein b, a.done = trueb donein main, a.done=true, b.done=true 解决方案1","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/tags/nodejs/"},{"name":"commonjs","slug":"commonjs","permalink":"https://chanran.github.io/tags/commonjs/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"https://chanran.github.io/categories/nodejs/"}]},{"title":"记录读过的有意义的书籍","slug":"记录读过的有意义的书籍","date":"2016-11-13T11:50:50.000Z","updated":"2016-12-16T08:27:07.952Z","comments":true,"path":"2016/11/13/记录读过的有意义的书籍/","link":"","permalink":"https://chanran.github.io/2016/11/13/记录读过的有意义的书籍/","excerpt":"","text":"无论书读没读完,都对自己的成长有帮助。 文学类《薄暮》《三国演义》《水浒传》杂志类《青年文摘》《读者》《哲思》技术书籍 技术无分方向,学多了实践多了便会贯通。 《HTML5 Canvas核心技术 图形、动画与游戏开发》《深入React技术栈》《React精髓》《JavaScript高级程序设计(第2版)》《JavaScript权威指南》《Javascript Dom编程设计(第3版)》《HTTP权威指南》《Node.js权威指南》《C++ Primer(第5版)》《白帽子讲Web安全(纪念版)》《数据库系统概念》《Linux指令范例速查手册》(当做字典查指令)","categories":[{"name":"阅读","slug":"阅读","permalink":"https://chanran.github.io/categories/阅读/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"https://chanran.github.io/tags/书籍/"},{"name":"阅读","slug":"阅读","permalink":"https://chanran.github.io/tags/阅读/"}],"keywords":[{"name":"阅读","slug":"阅读","permalink":"https://chanran.github.io/categories/阅读/"}]},{"title":"[转载]计算机常用英语术语、词汇表","slug":"转载-计算机专业术语","date":"2016-11-12T07:48:15.000Z","updated":"2016-11-12T08:35:44.302Z","comments":true,"path":"2016/11/12/转载-计算机专业术语/","link":"","permalink":"https://chanran.github.io/2016/11/12/转载-计算机专业术语/","excerpt":"","text":"转载自计算机常用英语术语、词汇表 Computer Vocabulary In Common Use一、硬件类(Hardware)二、软件类(Software)三、网络类(Network)四、其它 CPU(Center Processor Unit)中央处理单元mainboard主板RAM(random accessmemory)随机存储器(内存)ROM(Read Only Memory)只读存储器Floppy Disk软盘Hard Disk硬盘CD-ROM光盘驱动器(光驱)monitor监视器keyboard键盘mouse鼠标chip芯片CD-R光盘刻录机HUB集线器Modem= MOdulator-DEModulator,调制解调器P-P(Plug and Play)即插即用UPS(Uninterruptable Power Supply)不间断电源BIOS(Basic-input-OutputSystem)基本输入输出系统CMOS(Complementary Metal-Oxide-Semiconductor)互补金属氧化物半导体setup安装uninstall卸载wizzard向导OS(Operation Systrem)操作系统OA(Office AutoMation)办公自动化exit退出edit编辑copy复制cut剪切paste粘贴delete删除select选择find查找select all全选replace替换undo撤消redo重做program程序license许可(证)back前一步next下一步finish结束folder文件夹Destination Folder目的文件夹user用户click点击double click双击right click右击settings设置update更新release发布data数据data base数据库DBMS(Data Base ManegeSystem)数据库管理系统view视图insert插入object对象configuration配置command命令document文档POST(power-on-self-test)电源自检程序cursor光标attribute属性icon图标service pack服务补丁option pack功能补丁Demo演示short cut快捷方式exception异常debug调试previous前一个column行row列restart重新启动text文本font字体size大小scale比例interface界面function函数access访问manual指南active激活computer language计算机语言menu菜单GUI(graphical userinterfaces )图形用户界面template模版page setup页面设置password口令code密码print preview打印预览zoom in放大zoom out缩小pan漫游cruise漫游full screen全屏tool bar工具条status bar状态条ruler标尺table表paragraph段落symbol符号style风格execute执行graphics图形image图像Unix用于服务器的一种操作系统Mac OS苹果公司开发的操作系统OO(Object-Oriented)面向对象virus病毒file文件open打开colse关闭new新建save保存exit退出clear清除default默认LAN局域网WAN广域网Client/Server客户机/服务器ATM( AsynchronousTransfer Mode)异步传输模式Windows NT微软公司的网络操作系统Internet互联网WWW(World Wide Web)万维网protocol协议HTTP超文本传输协议FTP文件传输协议Browser浏览器homepage主页Webpage网页website网站URL在Internet的WWW服务程序上用于指定信息位置的表示方法Online在线Email电子邮件ICQ网上寻呼Firewall防火墙Gateway网关HTML超文本标识语言hypertext超文本hyperlink超级链接IP(Address)互联网协议(地址)SearchEngine搜索引擎TCP/IP用于网络的一组通讯协议Telnet远程登录IE(Internet Explorer)探索者(微软公司的网络浏览器)Navigator引航者(网景公司的浏览器)multimedia多媒体ISO国际标准化组织ANSI美国国家标准协会able 能activefile 活动文件addwatch 添加监视点allfiles 所有文件allrightsreserved 所有的权力保留altdirlst 切换目录格式andfixamuchwiderrangeofdiskproblems 并能够解决更大范围内的磁盘问题andotherinFORMation 以及其它的信息archivefileattribute 归档文件属性assignto 指定到autoanswer 自动应答autodetect 自动检测autoindent 自动缩进autosave 自动存储availableonvolume 该盘剩余空间badcommand 命令错badcommandorfilename 命令或文件名错batchparameters 批处理参数binaryfile 二进制文件binaryfiles 二进制文件borlandinternational borland国际公司bottommargin 页下空白bydate 按日期byextension 按扩展名byname 按名称bytesfree 字节空闲callstack 调用栈casesensitive 区分大小写causespromptingtoconfirmyouwanttooverwritean 要求出现确认提示,在你想覆盖一个centralpointsoftwareinc central point 软件股份公司changedirectory 更换目录changedrive 改变驱动器changename 更改名称characterset 字符集checkingfor 正在检查checksadiskanddisplaysastatusreport 检查磁盘并显示一个状态报告chgdrivepath 改变盘/路径 node 节点npasswd UNIX的一种代理密码检查器，在提交给密码文件前，它将对潜在的密码进行筛选。OSPF 开放最短路径优先协议OSI Model 开放系统互连模式out-of-band attack 带外攻击packet filter 分组过滤器password 口令path 路径payload 净负荷PBX 专用交换机PCS 个人通信业务peer 对等permission 权限plaintext 明文PPTP 点到点隧道协议port 端口prority 优先权protocol 协议potential browser 潜在浏览器POP 互联网电子邮件协议标准是Post Office Protocol 的缩写，是互联网电子邮件协议标准。我们可以通过有POP服务功能的主机传送及接收电子邮件。该协议的缺陷是，当你接收电子邮件时，所有的信件都从服务器上清除，下载到你的本地硬盘。当然也有一些客户端程序可以将电子邮件留在服务器上，或设置成超过一定大小的文件不可下载。随着邮件采用多媒体格式，邮件会越来越大，我们希望能够灵活掌握下载什么文件、何时下载，这就需要IMAP 协议。目前POP的版本为POP3。process 进程proxy 代理proxy server 代理服务器代理服务就是代理Web用户去取得资料回来，通常使用WWW软件要去连结远方的终端取得资料时，必须送出要求信号然后再一个字节一个字节的传送回来。有了proxy的设定以后，要求资料的信号会先送到Proxy Server。当Proxy Server得到用户的请求时，首先会到cache中寻找有没有同样的资料，如果有，就由Proxy Server直接将资料传给用户，如果cache没有资料，Proxy Server就会利用网络上所可以使用的频宽，到远端站台取回资料，一边储存在cache中，一边传送给用户。即使线路阻塞，还是比用户自己直接抓取要来得快速的。paseudorandom 伪随机phreaking 指控制电话系统的过程RAS 远程访问服务Remote control 远程控制RPC 远程过程调用remote boot 远程引导route 路由router 路由器routing 路由选择RIP 路由选择信息协议routed daemon 一种利用RIP的UNIX寻径服务routing table 路由表R.U.P 路由更新协议RSA 一种公共密匙加密算法。而RSA也许是最流行的。script 脚本search engine 搜索引擎SSL 安全套接层secure 密码SID 安全标识符sender 发送者SLIP 串行线网际协议server 服务器server-based network 基于服务器的网络session layer 会话层share、sharing 共享share-level security 共享级安全性SMTP 简单邮件传送协议SNMP 简单网络管理协议Site 站点SCSI 小型计算机系统接口snffer 检错器snooping 探听standalone server 独立服务器strong cipher 强密码stream cipher 流密码strong password 强口令SQL 结构化查询语言subnet mask 子网掩码subdirectory 子目录subnet 子网swap file 交换文件SACL 系统访问控制表S/Key 安全连接的一次性密码系统，在S/Key中，密码从不会经过网络发送，因此不可能被窃取。sniffer（嗅探器） 秘密捕获穿过网络的数据报文的程序，黑客一般用它来设法盗取用户名和密码的。spoofing（电子欺骗） 任何涉及假扮其他用户或主机以对目标进行未授权访问的过程time bomb（时间炸弹） 指等待某一特定时间或事件出先才激活，从而导致机器故障的程序TCPDUMP 是UNIX中捕获数据包的实用工具，常被用语获得详细的网络通信记录的。Traceroute 一个UNIX上的常用TCP程序，用语跟踪本机和远程主机之间的路由T0,DS0 56或者64kbpsT1,DS1 24路PCM数字话，总速率为1.544MbpsT3,DS3 28个T1信道，作品能够速率为44.736Mbpsthin client 瘦客户机thread 线程throughput 吞吐量transport layer 传输量Transport Protocol 传输协议trust 信任tunnel 安全加密链路vector of attack 攻击向量Virtual directory 虚目录Virtual Machine 虚拟机VRML 虚拟现实模型语言volume 文件集vulnerability 脆弱性weak passwurd 弱口令well-known ports 通用端口workstation 工作站X.25 一种分组交换网协议zone transfer 区域转换 authentication 认证、鉴别authorization 授权Back Office Microsoft公司的一种软件包Back up 备份backup browser 后备浏览器BDC 备份域控制器baseline 基线BIOS 基本输入/输出系统Binding 联编、汇集bit 比特、二进制位BOOTP 引导协议BGP 引导网关协议Bottleneck 瓶径bridge 网桥、桥接器browser 浏览器browsing 浏览channel 信道、通路CSU/DSU 信道服务单元/数字服务单元Checksum 校验和Cluster 簇、群集CGI 公共网关接口CGI（Common Gateway Interface公用网关接口是一个可以产生相同结果或结果随用户输入而变化的程序。它可以用一种解释性的界面语言编写，也可以用一种编译方式的编程语言编写。CGI规定了Web服务器调用其它可执行程序的接口协议标准。Web服务器通过调用CGI程序实现和Web浏览器的交互，也就是CGI程序接受Web浏览器发送给Web服务器的信息，进行处理，并将响应结果再回送给Web服务器和Web浏览器。CGI程序一般完成Web网页中表单数据的处理、数据库查询和实现与传统应用系统的集成等工作。CGI程序虽然可以用任何程序设计语言编写，但是用C语言编写的CGI程序具有执行速度快、安全性高等特点。CGI-based attack（基于CGI攻击）它利用公共网关接口的脆弱点进行攻击，通常借助www站点进行crash（崩溃） 系统突然失效，需要从新引导CD-ROM 只读型光盘Component 组件data link 数据链路datagram 数据报default document 缺省文档digital key system 数字键控系统disk mirroring 磁盘镜像distributed file system 分布式文件系统data-driven attack（数据驱动攻击）依靠隐藏或者封装数据进行的攻击，那些数据可不被察觉的通过防火墙。DNS spoofing（域名服务器电子欺骗）攻击者用来损害域名服务器的方法，可通过欺骗DNS的高速缓存或者内应攻击来实现的一种方式（通常为攻击者假扮合法的DNS服务器角色）DoS（嘿嘿，可不是DOS哦，这个是deniad of service，极为服务拒绝）用户恶意使用网络信息服务器时，将拒绝为合法的用户提供服务。eavesdropping 窃听、窃取encrypted tunnel 加密通道enterprise network 企业网Ethernet 以太网External security 外部安全性environment variable 环境变量fax modem 传真猫file attribute 文件属性file system 文件系统file 文件FORM 格式fragments 分段frame relay 桢中继firewall 防火墙Firework(防火墙)是加强加 Internet 与 Intranetp(内部网)之间安全防范的一个或一组系统。防火墙可以确定哪些内部服务允许外部访问，哪些外人被许可访问所允许的内部服务，那些外部服务可由内部人员访问。为了使防火墙发挥效力，来自和发往 Internet 的所有信息都必须经由防火墙出入。防火墙只允许授权信息通过，而防火墙本身不能被渗透。gated daemon gated进程（好象是一种早期的UNIX寻径服务）gateway 网关global account 全局帐号global group 全局组group 组group account 组帐号group identifier 组标识符HCL 硬件兼容性表hash 散表HPFS 高性能文件系统Home directory 主目录home page 竹叶hop 驿站、中继段host 主机hyperlink 超文本链接highjacking 劫持终端，即为攻击者捕获另一个用户会话的控制。这是很少发生的，一旦发生就表明目标的安全性已经被破坏。其实NetXRay在这一点就做的很好。HTPASSWD 一种用密码来保护WWW(UNIX)上的站点的系统icon 图标impersonation attack 伪装攻击index server 索引服务器ISA 工业标准结构Inherieted Rights Filter 继承权限过滤器ISDN 综合业务数字网interactive user 交互性用户intermediate system 中介系统internal security 内部安全性Internet Explorer（IE） IBM的万维网浏览器Internet server 因特网服务器Interpreter 解释程序intranet 内联网，企业内部网intruder 入 侵 者IMAP 一种邮件协议是Internet Message Access Protocal 的缩写。IMAP 提供了一个在远程服务器上管理邮件的手段，它与POP 协议相似，但功能比POP 要多，功能包括：只下载邮件的标题、建立多个邮箱和在服务器上建立保存邮件的文件夹。Java Virtual Machine Java虚拟机java script 基于Java语言的一种脚本语言jack in 一句黑客常用的口语，意思为破坏服务器安全的行为kernel 内核keys 密钥keyspace 密钥空间Keystroke Recorder（按键记录器） 一些用语窃取他人用户名和密码的工具LAN Server 局域网服务器Local security 局部安全性log 日志、记录logging 登录logoff 退出、注销logical port 逻辑端口logon 注册logon script 登录脚本LFN 长文件名logic bomb（逻辑炸弹）一种可导致系统加锁或者故障的程序或代码。mass browser 主浏览器MAPI是Messaging Application Progrmming Interface 的缩写。微软和其它一些公司开发了MAPI，可使Windows 应用程序接入到从Microsoft Mail 到Novell MHS的多种消息系统。但是， MAPI仅限于在日常工作的水平上工作，即感知邮件的应用程序，它可在网络上交换邮件与数据。member server 成员服务器menu 菜单message 消息multilink 多链接MIME 多媒体Internet邮件扩展MPR 多协议路由器multiprocessing 多重处理Module 模块multihomed host 多穴主机MUDMUD的英文全名是Multiple User Dimension、Multiple User Dialogue或Multiple User Dungeon，译为“多人世界”、“多人对话”或“多人地牢”，俗称“泥巴”游戏。named pipes 命名管道NDS NetWare目录服务NetBEUI NetBIOS扩展用户接口NetBIOS gateway NetBIOS网关NetWare 网络操作系统（不好意思，我忘了是那个公司开发的了）network 网络NetBIOS 网络基本输入/输出系统NDIS 网络驱动程序接口规范NetDDE 网络动态数据交换NIC 网络接口卡network layer 网络层Network Monitor 一个网络监控程序network operating system 网络操作系统network printer 网络打印机network security 网络安全network user 网络用户NFS 网络文件系统 我把网络安全方面的专业词汇整理了一下，虽然大多是乱谈，但初衷在于初学者能更好的了解这些词汇。不全和错误的地方还望高手补充：Access Control List（ACL） 访问控制列表access token 访问令牌account lockout 帐号封锁account policies 记帐策略accounts 帐号adapter 适配器adaptive speed leveling 自适应速率等级调整Address Resolution Protocol(ARP) 地址解析协议Administrator account 管理员帐号ARPANET 阿帕网（internet的前身）algorithm 算法alias 别名allocation 分配、定位alias 小应用程序allocation layer 应用层API 应用程序编程接口anlpasswd 一种与Passwd+相似的代理密码检查器applications 应用程序ATM 异步传递模式attack 攻击audio policy 审记策略auditing 审记、监察back-end 后端borde 边界borde gateway 边界网关breakabie 可破密的breach 攻破、违反cipher 密码ciphertext 密文CAlass A domain A类域CAlass B domain B类域CAlass C domain C类域classless addressing 无类地址分配cleartext 明文CSNW Netware客户服务client 客户，客户机client/server 客户机/服务器code 代码COM port COM口（通信端口）CIX 服务提供者computer name 计算机名crack 闯入cryptanalysis 密码分析DLC 数据链路控制decryption 解密database 数据库dafault route 缺省路由dafault share 缺省共享denial of service 拒绝服务dictionary attack 字典式攻击directory 目录directory replication 目录复制domain 域domain controller 域名控制器domain name 域名域名其实就是入网计算机的名字，它的作用就象寄信需要写明人们的名字、地址一样重要。域名结构如下：计算机主机名.机构名.网络名.最高层域名。域名用文字表达，比用数字表达的IP地址容易记忆。加入Internet的各级网络依照DNS的命名规则对本网内的计算机命名，并负责完成通讯时域名到IP地址的转换 。DNS 域名服务器DNS(Domain Name System,域名系统)是指在 Internet上查询域名或IP地址的目录服务系统。在接收到请求时，它可将另一台主机的域名翻译为IP地址，或反之。大部分域名系统都维护着一个大型的数据库，它描述了域名与 IP地址的对应关系，并且这个数据库被定期地更新。翻译请求通常来自网络上的另一台计算机，它需要IP地址以便进行路由选择。DDE 动态数据交换DHCP 动态主机配置协议encryption 加密EGP 外部网关协议FDDI 光纤分布式数据接口FAT 文件分配表FTP(File Transfer Protocol） 文件传送协议filter 过滤器firmware 固件flooding 淹没GSNW NetWare网关服务GDI(graphical device interface) 图形设备界面GUI 图形用户界面HTML 超文本标记语言HTTP 超文本传送协议IGP 内部安全性ICMP(Internet Control Message Protocol) 网际控制报文协议ICMP用来发送关于IP数据报传输的控制和错误信息的TCP/IP协议。当一个IP数据报不能传送到目的地时，可能是因为目的地的机器暂停服务或者信息交通阻塞，路由器可能使用ICMP将失败信息通知发送者。IGMP（Internet Group Management Protocol，Internet群组管理协议）这种TCP/IP协议允许Internet主机参加多点播送（multicasting）—-一种向计算机群广播信息的有效手段IIS 信息服务器IP(Internet Protocol) 网际协议IRC 网上交谈ISP 网络服务提供者IPX 互连网分组协议IPC 进程间通信IRQ 中断请求IP address IP地址IP地址称作网络协议地址，是分配给主机的一个32位地址，由4个字节组成，分为动态IP地址和静态IP地址两种。动态IP地址指的是每次连线所取得的地址不同，而静态IP地址是指每次连线均为同样固定的地址。一般情况下，以电话拨号所取得的地址均为动态的，也就是每次所取得的地址不同。IP masquerade IP伪装IP spoofing IP欺骗LAN 局域网LPC 局部过程调用NNTP 网络新闻传送协议PPP 点到点协议称为点对点通信协议(Point to Point Protocol)，是为适应那些不能在网络线上的使用者，通过电话线的连接而彼此通信所制定的协议。PDC 主域控制器Telnet 远程登陆TCP/IP 传输控制协议/网际协议TCP/IP通信协议主要包含了在Internet上网络通信细节的标准，以及一组网络互连的协议和路径选择算法。TCP是传输控制协议，相当于物品装箱单，保证数据在传输过程中不会丢失。IP是网间协议，相当于收发货人的地址和姓名，保证数据到达指定的地点。TFTP 普通文件传送协议TFTP是无盘计算机用来传输信息的一种简化的FTP协议。它非常之简单，所以可固化在硬盘上，而且支持无认证操作。TFTP是一种非常不安全的协议。Trojan Horse 特洛伊木马URL 统一资源定位器UDP 用户数据报协议VDM 虚拟DOS机UUCP 是一种基于猫的使用已经很久的文件传输协议，有时候还使用它在Internet上传输Usenet新闻和E-mail，尤其是在那些间断性联网的站点上。现在很少站提供匿名的UUCP来存取文件。而它做为一种文件传输协议，只有那些没有入网而使用猫的用户使用此方法。WWW 万维网WWW(Word Wide Web)是Internet最新的一种信息服务。它是一种基于超文本文件的交互式浏览检索工具。用户可用WWW在Internet网上浏览、传递、编辑超文本格式的文件。WAN 广域网virtual server 虚拟服务器Usenet用户交流网Usenet是网络新闻服务器的主要信息来源。Usenet完全是一个民间自发建立的，使用Internet交换信息但又不完全依赖Internet进行通讯的用户交流网络。使用Usenet的自愿者共同遵守一些约定的网络使用规则。USER name 用户名USER account 用户帐号Web page 网页OpenGL 开放图形语言ODBC 开放数据库连接PCI 外设连接接口 chooseoneofthefollowing 从下列中选一项clearall 全部清除clearallbreakpoints 清除所有断点clearsanattribute 清除属性clearscommandhistory 清除命令历史clearscreen 清除屏幕closeall 关闭所有文件codegeneration 代码生成colorpalette 彩色调色板commandline 命令行commandprompt 命令提示符compressedfile 压缩文件configuresaharddiskforusewithmsdos 配置硬盘,以为 MS-DOS 所用conventionalmemory 常规内存copiesdirectoriesandsubdirectoriesexceptemptyones 拷贝目录和子目录,空的除外copiesfileswiththearchiveattributeset 拷贝设置了归档属性的文件copiesoneormorefilestoanotherlocation 把文件拷贝或搬移至另一地方copiesthecontentsofonefloppydisktoanother 把一个软盘的内容拷贝到另一个软盘上copydiskette 复制磁盘copymovecompfindrenamedeletevervieweditattribwordpprintlist C拷贝M移动 O比 F搜索R改名 D删除 V版本 E浏览A属性 W写字 P打印 L列表copyrightc 版权(ccreatedospartitionorlogicaldosdrive 创建DOS分区或逻辑DOS驱动器createextendeddospartition 创建扩展DOS分区createlogicaldosdrivesintheextendeddospartition 在扩展DOS分区中创建逻辑DOS驱动器createprimarydospartition 创建DOS主分区createsadirectory 创建一个目录createschangesordeletesthevolumelabelofadisk 创建,改变或删除磁盘的卷标currentfile 当前文件currentfixeddiskdrive 当前硬盘驱动器currentsettings 当前设置currenttime 当前时间cursorposition 光标位置defrag 整理碎片dele 删去deletepartitionorlogicaldosdrive 删除分区或逻辑DOS驱动器deletesadirectoryandallthesubdirectoriesandfilesinit 删除一个目录和所有的子目录及其中的所有文件deltree 删除树devicedriver 设备驱动程序dialogbox 对话栏directionkeys 方向键directly 直接地directorylistargument 目录显示变量directoryof 目录清单directorystructure 目录结构diskaccess 磁盘存取diskcopy 磁盘拷贝diskservicescopycomparefindrenameverifyvieweditmaplocateinitialize 磁盘服务功能: C拷贝 O比较 F搜索R改卷名V校验 浏览E编缉M图 L找文件 N格式化diskspace 磁盘空间displayfile 显示文件displayoptions 显示选项displaypartitioninFORMation 显示分区信息displaysfilesinspecifieddirectoryandallsubdirectories 显示指定目录和所有目录下的文件displaysfileswithspecifiedattributes 显示指定属性的文件displaysorchangesfileattributes 显示或改变文件属性displaysorsetsthedate 显示或设备日期displayssetupscreensinmonochromeinsteadofcolor 以单色而非彩色显示安装屏信息displaystheamountofusedandfreememoryinyoursystem 显示系统中已用和未用的内存数量displaysthefullpathandnameofeveryfileonthedisk 显示磁盘上所有文件的完整路径和名称displaysthenameoforchangesthecurrentdirectory 显示或改变当前目录doctor 医生doesn 不doesntchangetheattribute 不要改变属性dosshell DOS 外壳doubleclick 双击doyouwanttodisplaythelogicaldriveinFORMationyn 你想显示逻辑驱动器信息吗(y/n)?driveletter 驱动器名editmenu 编辑选单emsmemory ems内存endoffile 文件尾endofline 行尾enterchoice 输入选择entiredisk 转换磁盘environmentvariable 环境变量esc esceveryfileandsubdirectory 所有的文件和子目录existingdestinationfile 已存在的目录文件时expandedmemory 扩充内存expandtabs 扩充标签explicitly 明确地extendedmemory 扩展内存fastest 最快的fatfilesystem fat 文件系统fdiskoptions fdisk选项fileattributes 文件属性fileFORMat 文件格式filefunctions 文件功能fileselection 文件选择fileselectionargument 文件选择变元filesin 文件在filesinsubdir 子目录中文件fileslisted 列出文件filespec 文件说明filespecification 文件标识filesselected 选中文件findfile 文件查寻fixeddisk 硬盘fixeddisksetupprogram 硬盘安装程序fixeserrorsonthedisk 解决磁盘错误floppydisk 软盘FORMatdiskette 格式化磁盘FORMatsadiskforusewithmsdos 格式化用于MS-DOS的磁盘FORMfeed 进纸freememory 闲置内存fullscreen 全屏幕functionprocedure 函数过程graphical 图解的graphicslibrary 图形库groupdirectoriesfirst 先显示目录组hangup 挂断harddisk 硬盘hardwaredetection 硬件检测hasbeen 已经helpfile 帮助文件helpindex 帮助索引helpinFORMation 帮助信息helppath 帮助路径helpscreen 帮助屏helptext 帮助说明helptopics 帮助主题helpwindow 帮助窗口hiddenfile 隐含文件hiddenfileattribute 隐含文件属性hiddenfiles 隐含文件howto 操作方式ignorecase 忽略大小写inbothconventionalanduppermemory 在常规和上位内存incorrectdos 不正确的DOSincorrectdosversion DOS 版本不正确indicatesabinaryfile 表示是一个二进制文件indicatesanasciitextfile 表示是一个ascii文本文件insertmode 插入方式insteadofusingchkdsktryusingscandisk 请用scandisk,不要用chkdskinuse 在使用invaliddirectory 无效的目录is 是kbytes 千字节keyboardtype 键盘类型labeldisk 标注磁盘laptop 膝上largestexecutableprogram 最大可执行程序largestmemoryblockavailable 最大内存块可用lefthanded 左手习惯leftmargin 左边界linenumber 行号linenumbers 行号linespacing 行间距listbyfilesinsortedorder 按指定顺序显示文件listfile 列表文件listof 清单locatefile 文件定位lookat 查看lookup 查找macroname 宏名字makedirectory 创建目录memoryinfo 内存信息memorymodel 内存模式menubar 菜单条menucommand 菜单命令menus 菜单messagewindow 信息窗口microsoft 微软microsoftantivirus 微软反病毒软件microsoftcorporation 微软公司mini 小的modemsetup 调制解调器安装modulename 模块名monitormode 监控状态monochromemonitor 单色监视器moveto 移至multi 多newdata 新建数据newer 更新的newfile 新文件newname 新名称newwindow 新建窗口norton nortonnostack 栈未定义noteusedeltreecautiously 注意:小心使用deltreeonlinehelp 联机求助optionally 可选择地or 或pageframe 页面pagelength 页长pausesaftereachscreenfulofinFORMation 在显示每屏信息后暂停一下pctools pc工具postscript 附言prefixmeaningnot 前缀意即”不prefixtoreverseorder 反向显示的前缀presetswitchesbyprefixinganyswitchwithhyphenforexamplew 用前缀和放在短横线-后的开关(例如/-w)预置开关pressakeytoresume 按一键继续pressanykeyforfilefunctions 敲任意键执行文件功能pressentertokeepthesamedate 敲回车以保持相同的日期pressentertokeepthesametime 敲回车以保持相同的时间pressesctocontinue 敲esc继续pressesctoexit 敲键退出pressesctoexitfdisk 敲esc退出fdiskpressesctoreturntofdiskoptions 敲esc返回fdisk选项previously 在以前printall 全部打印printdevice 打印设备printerport 打印机端口processesfilesinalldirectoriesinthespecifiedpath 在指定的路径下处理所有目录下的文件programfile 程序文件programmingenvironment 程序设计环境promptsyoubeforecreatingeachdestinationfile 在创建每个目标文件时提醒你promptsyoutopressakeybeforecopying 在拷贝前提示你敲一下键pulldown 下拉pulldownmenus 下拉式选单quickFORMat 快速格式化quickview 快速查看readonlyfile 只读文件readonlyfileattribute 只读文件属性readonlyfiles 只读文件readonlymode 只读方式redial 重拨repeatlastfind 重复上次查找reportfile 报表文件resize 调整大小respectively 分别地rightmargin 右边距rootdirectory 根目录runsdebugaprogramtestingandeditingtool 运行debug, 它是一个测试和编辑工具runtimeerror 运行时出错saveall 全部保存saveas 另存为scandisk 磁盘扫描程序scandiskcanreliablydetect scandisk可以可靠地发现screencolors 屏幕色彩screenoptions 屏幕任选项screensaver 屏幕暂存器screensavers 屏幕保护程序screensize 屏幕大小scrollbars 翻卷栏scrolllockoff 滚屏已锁定searchfor 搜索sectorspertrack 每道扇区数selectgroup 选定组selectionbar 选择栏setactivepartition 设置活动分区setupoptions 安装选项shortcutkeys 快捷键showclipboard 显示剪贴板singleside 单面sizemove 大小/移动sorthelp S排序H帮助sortorder 顺序specialservicesdirectorymaint 特殊服务功能: D目录维护specifiesdrivedirectoryandorfilestolist 指定要列出的驱动器,目录,和文件specifiesthatyouwanttochangetotheparentdirectory 指定你想把父目录作为当前目录specifiesthedirectoryandorfilenameforthenewfile 指定新文件的目录或文件名specifiesthefileorfilestobecopied 指定要拷贝的文件stackoverflow 栈溢出standalone 独立的startupoptions 启动选项statusline 状态行stepover 单步summaryof 摘要信息suppressespromptingtoconfirmyouwanttooverwritean 取消确认提示,在你想覆盖一个swapfile 交换文件switchesmaybepresetinthedircmdenvironmentvariable 开关可在dircmd环境变量中设置switchto 切换到sync 同步systemfile 系统文件systemfiles 系统文件systeminfo 系统信息systeminFORMation 系统信息程序tableofcontents 目录terminalemulation 终端仿真terminalsettings 终端设置testfile 测试文件testfileparameters 测试文件参数theactivewindow 激活窗口theswitchymaybepresetinthecopycmdenvironmentvariable /y开关可以在copycmd环境变量中预置thetwofloppydisksmustbethesametype 两个软磁盘必须是同种类型的thismaybeoverriddenwithyonthecommandline 在命令行输入/-y可以使之无效togglebreakpoint 切换断点tomsdos 转到MS-DOStopmargin 页面顶栏turnoff 关闭typecddrivetodisplaythecurrentdirectoryinthespecifieddrive 键入cd驱动器:显示指定驱动器的当前目录typecdwithoutparameterstodisplaythecurrentdriveanddirectory 键入无参数的cd以显示当前驱动器的当前目录typedatewithoutparameterstodisplaythecurrentdatesettingand 键入无参数的date,显示当前日期设置和unmark 取消标记unselect 取消选择usesbareFORMat 使用简洁方式useslowercase 使用小写useswidelistFORMat 使用宽行显示usinghelp 使用帮助verbosely 冗长地verifiesthatnewfilesarewrittencorrectly 校验新文件是否正确写入了videomode 显示方式viewwindow 内容浏览viruses 病毒vision 景象vollabel 卷标volumelabel 卷标volumeserialnumberis 卷序号是windowshelp windows 帮助wordwrap 整字换行workingdirectory 正在工作的目录worm 蠕虫writemode 写方式writeto 写到xmsmemory 扩充内存youmay 你可以","categories":[{"name":"翻译","slug":"翻译","permalink":"https://chanran.github.io/categories/翻译/"}],"tags":[{"name":"计算机术语","slug":"计算机术语","permalink":"https://chanran.github.io/tags/计算机术语/"}],"keywords":[{"name":"翻译","slug":"翻译","permalink":"https://chanran.github.io/categories/翻译/"}]},{"title":"[转载]web前端开发培训之前端开发必会的二十五个知识点","slug":"转载-web前端开发培训之前端开发必会的二十五个知识点","date":"2016-11-11T14:24:02.000Z","updated":"2016-11-12T04:10:53.092Z","comments":true,"path":"2016/11/11/转载-web前端开发培训之前端开发必会的二十五个知识点/","link":"","permalink":"https://chanran.github.io/2016/11/11/转载-web前端开发培训之前端开发必会的二十五个知识点/","excerpt":"","text":"转载自 web前端开发培训之前端开发必会的二十五个知识点 通用常用那几种浏览器测试？有哪些内核(Layout Engine)?(Q1) 浏览器：IE，Chrome，FireFox，Safari，Opera。(Q2) 内核：Trident，Gecko，Presto，Webkit。 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下） (Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。 (Q2) 兼容性：display:inline-block;*display:inline;*zoom:1; 清除浮动有哪些方式？比较好的方式是哪一种？ (Q1) （1）父级div定义height。 （2）结尾处加空div标签clear:both。 （3）父级div定义伪类:after和zoom。 （4）父级div定义overflow:hidden。 （5）父级div定义overflow:auto。 （6）父级div也浮动，需要定义宽度。 （7）父级div定义display:table。 （8）结尾处加br标签clear:both。 (Q2) 比较好的是第3种方式，好多网站都这么用。 box-sizing常用的属性有哪些？分别有什么作用？ (Q1)box-sizing: content-box|border-box|inherit; (Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 Doctype作用？标准模式与兼容模式各有什么区别? (Q1) &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 (Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 页面导入样式时，使用link和@import有什么区别？ （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、我们组建一大牛裙前面是4七一，整理讯息（例如加入CSS等），中间是零2七，以及计算网页的显示方式，后面是壹武四，是学习的就加，不是学习的请勿打扰。然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ (Q1) HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 (1)绘画 canvas; (2)用于媒介回放的 video 和 audio 元素; (3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; (4)sessionStorage 的数据在浏览器关闭后自动删除; (5)语意化更好的内容元素，比如 article、footer、header、nav、section; (6)表单控件，calendar、date、time、email、url、search; (7)新的技术webworker, websocket, Geolocation; (Q2) IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim， 12&lt;!--[if lt IE 9]&gt;&lt;![endif]--&gt; 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 JavaScript介绍js的基本数据类型 Undefined、Null、Boolean、Number、String js有哪些内置对象？ 数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error this对象的理解 this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)。 DOM怎样添加、移除、移动、复制、创建和查找节点&gt;12345678910111213// 创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点// 添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点// 查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 null和undefined的区别？ null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 new操作符具体干了什么呢? （1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 （2）属性和方法被加入到 this 引用的对象中。 （3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 JSON 的了解？ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。 格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} call() 和 apply() 的区别和作用？ apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。 如：function.apply(this,[1,2,3]); call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 如何获取UA？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; 其他 HTTP状态码知道哪些？ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 你有哪些性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 哪些常见操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 线程与进程的区别 一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。","categories":[{"name":"面试","slug":"面试","permalink":"https://chanran.github.io/categories/面试/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://chanran.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://chanran.github.io/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"https://chanran.github.io/categories/面试/"}]},{"title":"重构页面遇到的各种奇怪问题","slug":"重构页面遇到的各种奇怪问题","date":"2016-11-11T13:22:38.000Z","updated":"2016-11-29T12:29:04.169Z","comments":true,"path":"2016/11/11/重构页面遇到的各种奇怪问题/","link":"","permalink":"https://chanran.github.io/2016/11/11/重构页面遇到的各种奇怪问题/","excerpt":"","text":"记录一下干货 怎样可以很好地保证网页的浏览器兼容性 特定html标签相关的奇怪问题 textarea 123456&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;!--推荐这样写--&gt;&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt; &lt;!--会出现几个空格--&gt;&lt;/textarea&gt;&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt; &lt;!--换行之后有几个空格--&gt;&lt;/textarea&gt; chrome下第二个textarea会出现几个空格,第三个textarea会换行再加几个空格,所以最好使用第一个textarea的写法句号 (其他浏览器有空切换到windows测试) css相关的奇怪问题行内块元素之间的奇怪间隔 以span为例(设置了display:inline-block) 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body,div&#123; height:100%; width:100%; &#125; #span1&#123; display:inline-block; width:45%; height:100%; background-color:black; &#125; #span2&#123; display:inline-block; width:45%; height:100%; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span id=&quot;span1&quot;&gt;&lt;/span&gt; &lt;span id=&quot;span2&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 左图出现奇怪的间距(元素换行之后会有一个换行符),右图是解决之后的状态 解决方法 把行内块元素写一在同一行 (不推荐,如果元素多的话太长了,可读性差) 123&lt;div&gt; &lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;span2&quot;&gt;&lt;/span&gt;&lt;/div&gt; 加注释(推荐) 1234&lt;div&gt; &lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;&lt;!-- --&gt;&lt;span id=&quot;span2&quot;&gt;&lt;/span&gt;&lt;/div&gt; 用浮动(不推荐,脱离文本流了,弄起来有点麻烦) height:100%的问题height:100%不起作用12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;div style=&quot;height: 100%;background-color:red&quot;&gt; &lt;p&gt; 想让这个div高度为 100% 。但是不能实现 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; height:100%这个可以看做是继承的,div没有向上继承过来的height:100%,所以不可以实现height:100%; 正确的姿势是这样的(记得内联元素最好要放外部文件哦):123456789&lt;html style=&quot;height: 100%;&quot;&gt; &lt;body style=&quot;height: 100%;&quot;&gt; &lt;div style=&quot;height: 100%;background-color:red&quot;&gt; &lt;p&gt; 这样这个div的高度就会100%了 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; height:100%之后出现滚动条未完待续…","categories":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}],"tags":[{"name":"重构","slug":"重构","permalink":"https://chanran.github.io/tags/重构/"},{"name":"css","slug":"css","permalink":"https://chanran.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://chanran.github.io/tags/html/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}]},{"title":"stylus预处理入门(三)--插值","slug":"stylus预处理入门三插值","date":"2016-11-01T05:56:17.000Z","updated":"2016-11-29T12:29:52.026Z","comments":true,"path":"2016/11/01/stylus预处理入门三插值/","link":"","permalink":"https://chanran.github.io/2016/11/01/stylus预处理入门三插值/","excerpt":"","text":"插值(interporation) 插值相当于解析表达式或者变量，让它们的值替换插值的位置。注： 不能用于属性值的插值（但属性值可以使用变量替换）。 在css属性名中使用插值 1234partOfProp = radiusvalue = 10pxdiv border-&#123;partOfProp&#125; value /*切记属性值这里不可以使用插值*/ 转化：123div &#123; border-radius: 10px;&#125; 在选择器中使用插值 12345selector = divpartOfProp = radiusvalue = 10px&#123;selector&#125; border-&#123;partOfProp&#125; value 转化：123div &#123; border-radius: 10px;&#125; 1234selectors = &apos;#foo,#bar,.baz&apos;&#123;selectors&#125; background: #000 转化：12345#foo,#bar,.baz &#123; background: #000;&#125; 高级使用：与mixins配合使用 12345678910111213vendor(prop, args) -webkit-&#123;prop&#125; args -moz-&#123;prop&#125; args &#123;prop&#125; argsborder-radius() vendor(&apos;border-radius&apos;, arguments)box-shadow() vendor(&apos;box-shadow&apos;, arguments)button border-radius 1px 2px / 3px 4px 转化12345button &#123; -webkit-border-radius: 1px 2px / 3px 4px; -moz-border-radius: 1px 2px / 3px 4px; border-radius: 1px 2px / 3px 4px;&#125; 高级使用：与循环迭代(iteration)配合使用 1234table for row in 1 2 3 4 5 tr:nth-child(&#123;row&#125;) height: 10px * row 转化：123456789101112131415table tr:nth-child(1) &#123; height: 10px;&#125;table tr:nth-child(2) &#123; height: 20px;&#125;table tr:nth-child(3) &#123; height: 30px;&#125;table tr:nth-child(4) &#123; height: 40px;&#125;table tr:nth-child(5) &#123; height: 50px;&#125; QUOTE: If you are not moving ahead , you are falling behind.","categories":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/tags/css/"},{"name":"stylus","slug":"stylus","permalink":"https://chanran.github.io/tags/stylus/"},{"name":"预处理器","slug":"预处理器","permalink":"https://chanran.github.io/tags/预处理器/"},{"name":"前端","slug":"前端","permalink":"https://chanran.github.io/tags/前端/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}]},{"title":"stylus预处理入门(二)--变量","slug":"stylus预处理入门二变量","date":"2016-11-01T05:54:34.000Z","updated":"2016-11-29T12:29:44.625Z","comments":true,"path":"2016/11/01/stylus预处理入门二变量/","link":"","permalink":"https://chanran.github.io/2016/11/01/stylus预处理入门二变量/","excerpt":"","text":"变量(variables) 变量的标识符可以由$、下划线、字母、数字组成，其中数字不能作为变量的开头。其实这里的变量只是理解为单纯的字符替换 外部定义变量：12345_font-size = 14pxfont = _font-size &quot;Lucida Grande&quot;, Arialbody font font, sans-serif 转化：123body &#123; font: 14px &quot;Lucida Grande&quot;, Arial, sans-serif;&#125; 下面是变量的另外一种用法，不在外部定义变量: 内部重新定义当前变量 12345#logo width: w = 150px height: h = 80px margin-left: (w / 2) margin-top: (h / 2) /*注意括号一定要加上*/ 转化：123456#logo &#123; width: 150px; height: 80px; margin-left: 75px; margin-top: 40px;&#125; 使用内部变量 12345#logo width: w = 150px height: h = 80px margin-left: (@width / 2) margin-top: (@height / 2) /*注意括号一定要加上*/ 转化：123456#logo &#123; width: 150px; height: 80px; margin-left: 75px; margin-top: 40px;&#125; 变量的深入用法：写在mixins里，与分支结构配合定义初始属性值等。 12345678910position() position: arguments z-index: 1 unless @z-index /*这里是mixins，如果不懂可以先忽略。*/#logo z-index: 20 position: absolute#logo2 position: absolute 转化：12345678#logo &#123; z-index: 20; position: absolute;&#125;#logo2 &#123; position: absolute; z-index: 1;&#125; 变量冒泡查询 先看一个栗子：123456789body color: red ul li color: blue p color:black a background-color: @color 转化：123456789101112body &#123; color: #f00;&#125;body ul li &#123; color: #00f;&#125;body ul li p &#123; color: #000;&#125;body ul li p a &#123; background-color: #000;&#125; 注：从当前层开始，一直往上层查询，直到找到为止，找不到则返回null。上面例子中选择器”body ul li p”就定义了color属性了，而且选择器a被”body ul li p”嵌套的。所以查询到了上层的color属性，停止查询。 QUOTE: If you are not moving ahead , you are falling behind.","categories":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/tags/css/"},{"name":"stylus","slug":"stylus","permalink":"https://chanran.github.io/tags/stylus/"},{"name":"预处理器","slug":"预处理器","permalink":"https://chanran.github.io/tags/预处理器/"},{"name":"前端","slug":"前端","permalink":"https://chanran.github.io/tags/前端/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}]},{"title":"stylus预处理入门(一)--选择器","slug":"stylus预处理入门一选择器","date":"2016-11-01T05:50:46.000Z","updated":"2016-11-29T12:29:59.514Z","comments":true,"path":"2016/11/01/stylus预处理入门一选择器/","link":"","permalink":"https://chanran.github.io/2016/11/01/stylus预处理入门一选择器/","excerpt":"","text":"相关网站 官网：stylus 中文文档：stylus中文版参考文档 by 张鑫旭 理解css预处理器：css预处理器初识 by 栓萝卜的棍子 三种css预处理器语言详解：less|sass|stylus by 开源中国 CSS预处理器语言的个人理解 用另外一种可读性高、语法性强的语言来写CSS。stylus可以使用循环、分支、定义变量和函数结构来写css，这样写起来既方便又快捷。 通过一种转换机制将这种语法转化为原生css。每种语言的转化机制也有很多种，可以使用各种语言官网的方法转化，例如less。也可以使用构建工具webpack的stylus-loader来将stylus语言转化为原生css。 stylus的特点 官网可以直接将stylus代码放在官网这一页测试生成原生css（本人硬加上去的特点） 通过缩进来解释语言（喜欢python的geek应该会比较喜欢）。 待补充.. 123body div color white 转化：123body div &#123; color:#fff;&#125; stylus的优点 类python语法（官网称stylus为pythonic）。 语法灵活（可选的括号，冒号，分号等）。 stylus的缺点 由于其语法灵活的问题，如果没有团队规范，那么就会带来团队开发混乱，维护起来比较麻烦，各种语法混杂。 stylus语法介绍选择器(selectors)缩进(换行缩进表示语句前进)12body color:white; 转化：123body&#123; color:white;&#125; 同级选择器 element,element 123divp color:white; 转化：123div,p&#123; color:white;&#125; element element 123div p color:white; 转化：123div p&#123; color:white;&#125; element &gt;element 123div &gt;p color:white; 转化：123div &gt;p&#123; color:white;&#125; element +element 123div +p color:white; 转化：123div +p&#123; color:white;&#125; 例外：123foo bar baz&gt;span color:white; 注：上面代码的foo bar baz编译器解析有可能是”标签 属性 属性”，有可能是”标签 标签 标签”（有可能是自定义的标签）（编译器只会识别文档结构而不是标签或者属性） 建议写成下面这样（在最后的选择器后面加一个逗号[comma]）：12foo bar baz,&gt;span 注：上面的同级选择器是这里的优化，没有提到的其他选择器大多数保留原来的语法，或者与上面的语法类似，当然上面提到的选择器也可以使用原来的语法 引用父级选择器 使用&amp;指向父级选择器，有可能是选择器数组，也有可能是单独的一个选择器。 12345divp color:#FFF; &amp;:hover color:#000; 转化：12345678div,p &#123; color: #fff;&#125;div:hover,p:hover &#123; color: #000;&#125; 解释：其实”&amp;”可以理解为代替了上一层的选择器，比如上面例子，”&amp;”的上一层是”div,p”，这样说比较好理解。 下面是引用父级选择器的另一个例子 123456789101112box-shadow() -webkit-box-shadow arguments -moz-box-shadow arguments box-shadow arguments html.ie8 &amp;, html.ie7 &amp;, html.ie6 &amp; border 2px solid arguments[length(arguments) - 1]body #login box-shadow 1px 1px 3px #eee 转化：12345678910body #login &#123; -webkit-box-shadow: 1px 1px 3px #eee; -moz-box-shadow: 1px 1px 3px #eee; box-shadow: 1px 1px 3px #eee;&#125;html.ie8 body #login,html.ie7 body #login,html.ie6 body #login &#123; border: 2px solid #eee;&#125; 注：如果想在代码里使用”&amp;”符号而不是stylus的”&amp;”，可以在&amp;字符前加一个反斜杠并加上引号，如下： 1.foo[title*=&apos;\\&amp;&apos;] /*.foo[title*=&apos;&amp;&apos;]*/ 部分引用父级选择器之单层选择器 使用^ [N] 引用第N层父级选择器。如果N是正数，这里的第N层指的是最上层上层选择器到第N层选择器，如果N是负数，这里的第N层指的是最上层选择器到倒数第|N|层选择器。 有&amp;的情况： 123456.foo &amp;__bar width: 10px ^[0]:hover &amp; width: 20px 转化：123456.foo__bar &#123; width: 10px;&#125;.foo:hover .foo__bar &#123; width: 20px;&#125; 没有&amp;的情况： 123456.foo .bar width: 10px ^[0]:hover &amp; width: 20px 转化：123456.foo .bar &#123; width: 10px;&#125;.foo:hover .foo .bar &#123; width: 20px;&#125; N为0或者正数则从最上层开始到最下层，N为负数则从最下层开始到最上层。其实第N层的选择器是包含了上一层的选择器的，例如下面的例子，第一层选择器是foo,第二层就是foo bar,第三层是foo bar baz，如此类推（官网说的是嵌套）。 1234567.foo bar baz width: 10px ^[-1]:hover &amp; width: 20px 转化：123456.foo bar baz &#123; width: 10px;&#125;.foo bar:hover .foo bar baz &#123; width: 20px;&#125; 注：如果写在mixins里的话，推荐将N写成负数。因为你并不知道你在调用哪一层（ 有可能还有隐藏的上层选择器） 部分引用父级选择器之范围选择器 ^ [N..M] 引用第N层选择器到第M层选择器组成的选择器。注：这里有些跟引用单层选择器有点不同，这里的第几层是不包括上层选择器的，具体来看例子感受一下。 1234567.foo bar baz test width: 10px ^[-1]:hover ^[-2..-1] width: 20px 转化：123456.foo bar baz test &#123; width: 10px;&#125;.foo bar baz:hover baz test &#123; width: 20px;&#125; 其他部分引用父级选择器 最上层父级选择器(~/)，相当于^ [0] 1234.block &amp;__element ~/:hover &amp; color: red 转化：123.block:hover .block__element &#123; color: #f00;&#125; 相对父级选择器(../) 1234567.foo bar baz test width: 10px ../:hover ^[-1..-2] width: 20px 转化：123456.foo .bar .baz .test &#123; width: 10px;&#125;.foo .bar .baz:hover .baz .test &#123; width: 20px;&#125; 脱离嵌套的选择器(/) 1234567divp span color #A7A7A7 &amp;:hover, /.is-hovered color #000 转化：123456789div span,p span &#123; color: #a7a7a7;&#125;div span:hover,p span:hover,.is-hovered &#123; color: #000;&#125; 上面的例子里，转化后的代码.is-hovered已经脱离了嵌套结构了，已经不在任何选择器嵌套里。 选择器的值 selector()获取当前嵌套层的值，selectors()获取从最上层到当前层每一层的选择器的list 123456.foo &amp;:hover class selector() color black span color white 转化：1234567.foo:hover &#123; class: &apos;.foo:hover&apos;; /*这个是selector()的值*/ color: #000;&#125;.foo:hover span &#123; color: #fff;&#125; 123456.a .b &amp;__c content: selectors() span color white 转化：123456.a .b__c &#123; content: &apos;.a&apos;, &apos;&amp; .b&apos;, &apos;&amp;__c&apos;;&#125;.a .b__c span &#123; color: #fff;&#125; QUOTE: If you are not moving ahead , you are falling behind.","categories":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/tags/css/"},{"name":"stylus","slug":"stylus","permalink":"https://chanran.github.io/tags/stylus/"},{"name":"预处理器","slug":"预处理器","permalink":"https://chanran.github.io/tags/预处理器/"},{"name":"前端","slug":"前端","permalink":"https://chanran.github.io/tags/前端/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}]},{"title":"css3动画笔记","slug":"css3动画笔记","date":"2016-11-01T05:34:41.000Z","updated":"2016-11-29T12:29:36.273Z","comments":true,"path":"2016/11/01/css3动画笔记/","link":"","permalink":"https://chanran.github.io/2016/11/01/css3动画笔记/","excerpt":"","text":"some sites css3动画文档 by W3CSchool css3动画简介 by阮一峰 css3动画手册 by 腾讯 isux css3动画之硬件加速 by w3cplus 调试css3 动画 keyframe by w3ctech css动画的性能优化 by zencode.in 浏览器是如何渲染页面的 by code.leozhang2018.me (读完了之后会更加懂得如何提升css动画性能) 前端开发体系建设日记 by 张云龙 （这个链接是作为拓展的） transition grammar: tansition: property duration timing-function delay; detail transition-property：要过渡的css属性 transition-duration：要过渡持续多少秒或者毫秒 transition-timing-function：速度效果的速度曲线 transition-delay：延迟多少秒执行过渡 notice 默认值：transition:all 0 ease 0 如果transition-duration属性没有被设置，则默认为0，即不会产生过渡效果 tanstion-timing-function: linear/匀速/ | ease-in /加速/ | ease-out /减速/ | ease /逐渐放慢/ | cubic-bezier /函数，自定义速度模式，可以使用 工具网站 这个网站制作/ compatibility 目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。 不是所有的CSS属性都支持transition，完整的列表查看这里，以及具体的效果。 transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。 advantage : 简单易用 disavantage transition需要事件触发，所以没法在网页加载时自动发生。 transition是一次性的，不能重复发生，除非一再触发。 transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 animation grammar: name duration timing-function delay iteration-count direction detail @keyframes：规定动画 animation-name：绑定选择器的keyframe名称 animation-duration：动画的持续时间，以秒或者毫秒计 animation-timing-function：动画的速度曲线 animation-delay：延迟多少秒执行动画 animation-iteration-count：动画播放次数 animation-diretion：是否应该轮流反向播放动画 animation-play-state(通常用在js控制是否播放,object.style.animationPlayState)：（paused[停止] | running[播放]）规定动画正在播放还是暂停 animation-fill-mode(通常用在js控制动画效果是否可见,object.style.animationFillMode)：（none[不改变默认行为] | forwards[当动画完成后，保持最后一个属性值] | backwards[在animation-delay 所制定的一段时间内，在动画显示之前，应该开始属性值] | both[向前和向后填充模式都被应用]）规定动画在播放之前或之后，其动画效果是否可见。 compatibility Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。Chrome 和 Safari 需要前缀 -webkit- Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性 notice 默认值：animation:none 0 ease 0 1 normal 尽量少在@keyframe里使用除了transform,opacity,filter以外的元素，因为会触发浏览器的重绘(repaint)详情 @keyframe 定义：以百分比来规定改变发生的时间，或者通过关键词”from” 和 “to”，等价于0%和100%，0%是动画的开始时间，100%是结束时间 grammar:@keyframes animationname{ keyframes-selector { css-styles;} } detail animationname：（必需）定义动画名称 keyframes-selector：（必需）动画时长的百分比，合法的值：0%-100%（可以使用 from[0%] 和 to[100%]） css-styles：（必需）一个或多个合法的css样式属性 example @keyframes mymove { 0% {top:0px;} 25% {top:200px;} 50% {top:100px;} 75% {top:200px;} 100% {top:0px;} } @-moz-keyframes mymove /* Firefox */ { 0% {top:0px;} 25% {top:200px;} 50% {top:100px;} 75% {top:200px;} 100% {top:0px;} } @-webkit-keyframes mymove /* Safari 和 Chrome */ { 0% {top:0px;} 25% {top:200px;} 50% {top:100px;} 75% {top:200px;} 100% {top:0px;} } @-o-keyframes mymove /* Opera */ { 0% {top:0px;} 25% {top:200px;} 50% {top:100px;} 75% {top:200px;} 100% {top:0px;} } 如果animation-duration属性没有设置，则时长为0，即动画不会被播放 animation-iteration-count默认值为1，可设置为infinite（无限次播放） animation-direction:normal /正常播放/ | alternate /轮流反向播放/ advantage ：解决了transition过渡效果不能循环播放的弊端 disvantage：目前，IE 10和Firefox（&gt;= 16）支持没有前缀的animation，而chrome不支持，所以必须使用webkit前缀。代码必须写成下面这样。 div:hover { -webkit-animation: 1s rainbow; animation: 1s rainbow; } @-webkit-keyframes rainbow { 0% { background: #c00; } 50% { background: orange; } 100% { background: yellowgreen; } } @keyframes rainbow { 0% { background: #c00; } 50% { background: orange; } 100% { background: yellowgreen; } } transform grammar:transform:none | transform-functions detail:none and transform-functions none：不定义转换 matrix(n,n,n,n,n,n)：定义2D转换，使用六个值的矩阵 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)：定义3D转换，使用16个值的4X4矩阵 translate(x,y)：定义2D转换（参数：x轴移动量，y轴移动量。+即向右移动，-即向左移动。单独一个量时表示x轴移动量与y轴移动量相等） translate3d(x,y,z)：定义3D转换（参数基于translate(x,y)扩展） translateX(x)：定义转换，只用于X轴的值 translateY(y)：定义转换，只用于Y轴的值 translateZ(z)：定义转换，只用于Z轴的值 scale(x,y)：定义2D缩放转换（参数x,y是倍数） scale(x,y,z)：定义3D缩放转换（参数基于scale(x,y)扩展） scaleX(x)：设置X轴的值来定义缩放转换 scaleY(y)：设置Y轴的值来定义缩放转换 scaleZ(z)：设置Z轴的值来定义缩放转换 rotate(angle)：定义2D旋转。在参数中规定角度（正是顺时针，负是逆时针） rotate3d(x,y,z,angle)：定义3D旋转 rotateX(angle)：定义沿着X轴的3D旋转 rotateY(angle)：定义沿着Y轴的3D旋转 rotateZ(angle)：定义沿着Z轴的3D旋转 skew(x-angle,y-angle)：定义沿着X和Y轴的2D倾斜转换 skew(angle)：定义沿着X轴的2D倾斜转换 skew(angle)：定义沿着Y轴的2D倾斜转换 perspective(n)：为3D转换元素定义透视视图 compatibility Internet Explorer 10、Firefox、Opera 支持 transform 属性 Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换） Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换） Opera 只支持 2D 转换 Internet Explorer 10 和 Firefox 支持 3D 转换 Chrome 和 Safari 需要前缀 -webkit- Opera 仍然不支持 3D 转换（它只支持 2D 转换） notice transform-origin可以定义改变被转换元素的位置 grammar：transform-origin:x-axis,y-axis,z-zxis 默认值：transform-origin:50% 50% 0 detail x-axis | y-axis：定义视图被置于X轴的何处。可能的值：left | center | right | length | % z-axis：定义视图被置于Z轴的何处。可能的值：length compatibility Internet Explorer 10、Firefox、Opera 支持 transform-origin 属性 Internet Explorer 9 支持替代的 -ms-transform-origin 属性（仅适用于 2D 转换） Safari 和 Chrome 支持替代的 -webkit-transform-origin 属性（3D 和 2D 转换） Opera 只支持 2D 转换 transform-style规定如何在3D空间中呈现被嵌套的元素 grammar:transform-style:flat | preserve-3d tranform-style默认值：transform-style:flat compatibility Firefox 支持 transform-style 属性 Chrome、Safari 和 Opera 支持替代的 -webkit-transform-style 属性 perspective定义3D元素距视图的距离，以像素计。 grammar:perspective number | none perspective默认值：perspective:none detail 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身 perspective 属性只影响 3D 转换元素 通常和perspective-origin属性配合改变3D元素的底部位置 compatibility 目前浏览器都不支持 perspective 属性 Chrome 和 Safari 支持替代的 -webkit-perspective 属性 perspective-origin定义 3D 元素所基于的 X 轴和 Y 轴。该属性允许您改变 3D 元素的底部位置 grammar:perspective-origin:x-axis,y-axis perspective-origin默认值：perspective-origin:50% 50% detail 当为元素定义 perspective-origin 属性时，其子元素会获得透视效果，而不是元素本身 该属性必须与 perspective 属性一同使用，而且只影响 3D 转换元素 compatibility 目前浏览器都不支持 perspective-origin 属性 Chrome 和 Safari 支持替代的 -webkit-perspecitve-origin 属性 backface-visibility定义当元素不面向屏幕时是否可见 grammar:backface-visibility: visible | hidden backface-visibility默认值：backface-visibility:visible detail 如果在旋转元素不希望看到其背面时，该属性很有用 compatility 只有 Internet Explorer 10+ 和 Firefox 支持 backface-visibility 属性 Opera 15+、Safari 和 Chrome 支持替代的 -webkit-backface-visibility 属性 QUOTE: If you are not moving ahead , you are falling behind.","categories":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://chanran.github.io/tags/css3/"},{"name":"动画","slug":"动画","permalink":"https://chanran.github.io/tags/动画/"},{"name":"animation","slug":"animation","permalink":"https://chanran.github.io/tags/animation/"}],"keywords":[{"name":"css","slug":"css","permalink":"https://chanran.github.io/categories/css/"}]}]}